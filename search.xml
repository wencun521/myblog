<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>进程管理</title>
      <link href="/2023/04/05/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2023/04/05/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<ul><li>进程概述</li><li>进程控制块</li><li>进程的状态</li><li>线程管理</li><li>进程控制</li><li>处理机/CPU调度</li><li>同步&amp;互斥</li><li>信号量与管程</li><li>进程间通信的方式</li></ul><h2 id="一、进程概述"><a href="#一、进程概述" class="headerlink" title="一、进程概述"></a>一、进程概述</h2><p>进程：一个具有一定独立功能的程序在一个数据集合上一次动态执行过程。</p><p><strong>进程的组成</strong></p><ul><li>程序的代码</li><li>程序处理的数据</li><li>程序计数器中的值（下一条将运行指令的地址）</li><li>一组通用的寄存器的当前值，堆，栈</li><li>一组系统资源（如打开的文件）</li></ul><p><strong>进程与程序的联系</strong><br>1.程序是产生进程的<strong>基础</strong>。<br>2.程序的每次运行构成不同的进程。<br>3.进程是程序<strong>功能的体现</strong>。<br>4.通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。</p><p><strong>进程与程序的区别</strong><br>1.进程是动态的，程序是静态。程序是有序代码的集合；进程是程序的执行，进程会涉及到核心态和用户态的切换。<br>2.进程是暂时的，程序是永久的。进程是一个状态变化的过程，程序可长久保存。<br>3.进程与程序的组成不同。<br><strong>进程=程序+数据+进程控制块</strong>。</p><p><strong>进程的特点</strong><br>动态性：可动态地创建，结束进程。<br>并发性：进程可以被独立调度并占用处理机运行。<br>独立性：不同进程的工作不相互影响。<br>制约性：因访问共享数据或进程间同步而产生制约。</p><h2 id="二、进程控制块"><a href="#二、进程控制块" class="headerlink" title="二、进程控制块"></a>二、进程控制块</h2><p>PCB：操作系统管理控制进程运行所用的信息集合。<br>PCB是用来描述进程的数据结构。操作系统为<strong>每个进程</strong>都<strong>维护了一个PCB</strong>，用来保存与该进程有关的各种状态信息。</p><p><strong>PCB中存储的信息</strong></p><p>（一）进程标识信息<br>如本进程的<strong>标识</strong>，本进程的产生着标识（父进程标识），用户标识等。</p><p>（二）处理机状态信息保存区<br><strong>用户可见寄存器</strong>，用户程序可以使用的数据，地址等寄存器；<br><strong>控制和状态寄存器</strong>，如程序计数器，程序状态字；<br><strong>栈指针</strong>，系统带调用/中断处理和返回时需要用到它。</p><p>（三）进程控制信息<br><strong>调度和状态</strong>信息，用于操作系统进程并占用处理机使用。<br>进程间<strong>通信信息</strong>，为支持进程间的与通信相关的各种标识，信号等这些信息存在接收方的进程控制块中。<br><strong>存储管理信息</strong>，包含有指向本进程映像存储空间的数据结构。<br>进程<strong>所用资源</strong>，说明由进程打开，使用的系统资源。<br>有关<strong>数据结构连接信息</strong>，进程可以连接到一个进程队列中，或连接到相关其他进程的PCB。</p><p><strong>PCB的组织方式</strong></p><p>1.链表：同一状态的进程其PCB成一链表，多个状态对应多个不同的链表。如就绪链表，阻塞链表。<br>2.索引表：同一状态的进程归入一个index表，多个状态对应多个不同的index表。如就绪索引表，阻塞索引表。</p><p>注：一般会选择链表，因为可能面临进程创建，销毁等调度导致进程状态发生变化，所以链表能够更加灵活的插入和删除。</p><h2 id="三、进程的状态"><a href="#三、进程的状态" class="headerlink" title="三、进程的状态"></a>三、进程的状态</h2><p><strong>3.1 进程生命周期管理</strong></p><p>操作系统对于进程有一些生命周期的管理，大致有：</p><ul><li>进程创建</li><li>进程运行</li><li>进程等待</li><li>进程唤醒</li><li>进程结束</li></ul><p><strong>进程创建</strong></p><p>场景：<br>1.系统初始化。<br>2.用户请求创建一个新进程。<br>3.正在运行的进程执行了创建进程的系统调用。</p><p><strong>进程运行</strong></p><p>内核选择一个就绪进程，让它占用处理机并执行（和处理机调度算法有关）。</p><p><strong>进程等待（阻塞）</strong></p><p>场景：<br>1.请求并等待系统服务，无法马上完成。<br>2.启动某种操作，无法马上完成。<br>.需要的数据没有到达。</p><p>注：进程<strong>只能自己阻塞自己</strong>，因为只有进程自身才能知道何时需要等待某种时间的发生。</p><p><strong>进程唤醒</strong></p><p>场景：<br>1.被阻塞进程需要的资源可被满足。<br>2.被阻塞进程等待的事件到达。<br>3.将该进程的PCB插入到就绪队列。</p><p>注：进程只能被<strong>别的进程或操作系统唤醒</strong>。</p><p><strong>进程结束</strong></p><p>场景：<br>正常退出（自愿）<br>错误退出（自愿）<br>致命错误（强制）<br>被其他进程所杀（强制）</p><p><strong>3.2 进程的三种基本状态</strong></p><p><img src="https://s2.loli.net/2023/04/05/aPwNJ1lx7Z9VHkI.jpg" alt="img"></p><p>三种基本状态有<br><strong>运行状态</strong>：当一个进程正在处理机上运行时。<br><strong>就绪状态</strong>：一个进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。<br><strong>等待（阻塞）状态</strong>：一个进程正在等待某一事件而暂停运行。</p><p>其他基本状态<br><strong>创建状态</strong>：一个进程正在被创建，还没被转到就绪状态之前的状态。<br><strong>结束状态</strong>：一个进程正在从系统中消失时的状态。</p><p>到目前为止我们的认知应该是这个亚子…</p><p><img src="https://s2.loli.net/2023/04/05/ZxvuWzhOS4b3gJj.jpg" alt="img"></p><p>图片来源于网络</p><p>注：就绪也叫<strong>活动就绪</strong>；阻塞也叫<strong>活动阻塞</strong>。</p><p><strong>3.3 挂起</strong></p><p>学习操作系统应该都有听过挂起状态，有了阻塞为什么还要挂起呢，进程挂起和阻塞有什么区别，都将在下面整理。</p><p>挂起：<strong>把一个进程从内存转到外存</strong>。<br>进程在挂起时，不会占用内存空间。处在挂起状态的进程映像<strong>在磁盘上</strong>。</p><p><strong>挂起状态</strong><br>阻塞挂起状态：进程在外存并等待某事件的出现。<br>就绪挂起状态：进程在外存，但要进入内存，即可运行。</p><p>注：阻塞挂起也叫<strong>静止阻塞</strong>；就绪挂起也叫<strong>静止就绪</strong>。</p><p><strong>非挂起与挂起间的状态转换</strong><br>阻塞-&gt;阻塞挂起：没有进程处于就绪进程或就绪进程要求更多内存资源时，会进行这种转换，以提交新进程或运行就绪进程。</p><p>就绪-&gt;就绪挂起：当有高优先级阻塞进程和低优先级就绪进程时，系统会选择挂起低优先级就绪进程。</p><p>运行-&gt;就绪挂起：对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态。</p><p><strong>挂起与挂起间的状态转换</strong><br>阻塞挂起-&gt;就绪挂起：当有阻塞挂起进程因相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程。</p><p><strong>挂起与非挂起的状态转换</strong><br><strong>解挂/激活</strong>：把一个进程从外存转到内存。<br>就绪挂起-&gt;就绪：没有就绪进程或就绪进程优先级高于就绪进程时。<br>阻塞挂起-&gt;阻塞：当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起，进程转换为阻塞进程。</p><p>增加了挂起状态后，我们的认知应该更新为这个亚子：</p><p><img src="https://s2.loli.net/2023/04/05/L8jzVQCRdqDKYyp.jpg" alt="img"></p><p><strong>3.4 状态队列</strong></p><p>进程的状态这个多，操作系统是怎么管理的呢？操作系统维护了<strong>一组队列</strong>，表示系统中所有进程的当前状态。</p><p>简单来说，每个进程的<strong>PCB</strong>都根据它的状态加入到相应的队列中，当一个进程的状态发生变化时，它的PCB从一个状态队列中<strong>脱离</strong>出来，<strong>加入</strong>到另一个队列。</p><h2 id="四、线程管理"><a href="#四、线程管理" class="headerlink" title="四、线程管理"></a>四、线程管理</h2><p>多进程编程下，进程之间<strong>如何通信，共享数据</strong>。进程的<strong>维护开销较大</strong>，创建时需<strong>分配资源</strong>，建立PCB；撤销时，<strong>回收资源</strong>，撤销PCB；进程切换时，<strong>保存</strong>当前进程的状态信息。</p><p>此时需要一个实体能够实现<strong>并发执行</strong>，<strong>共享相同的地址空间</strong>的功能。因此，线程就出现了。线程是<strong>进程的一条执行流程</strong>。所以可以理解为<strong>进程=资源管理+线程</strong>。</p><p>进程有进程的PCB，线程有线程的TCB（线程控制块）。</p><p><strong>4.1 线程概述</strong></p><p><strong>线程的优点</strong></p><p>1.一个进程中可以同时存在多个线程<br>2.各个线程之间可以并发地执行<br>3.各个线程之间可以共享地址空间和文件等资源</p><p><strong>缺点</strong><br>一个线程崩溃（可能破坏了共享资源），会导致所属进程的所有线程崩溃。</p><p><strong>线程和进程的区别</strong></p><p>1.进程是<strong>资源分配</strong>的单位，线程是<strong>CPU调度</strong>的单位。<br>2.进程拥有一个<strong>完整的资源平台</strong>，而线程<strong>只独享必不可少的资源</strong>，如寄存器和栈。<br>3.线程同样具有<strong>就绪，阻塞</strong>和<strong>执行</strong>三种基本状态，同样具有状态之间的转换。<br>4.线程能<strong>减少并发执行的时间和空间开销</strong>：</p><ul><li>线程创建，终止时间比较短；</li><li>同一进程内的线程切换；</li><li>由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信。</li></ul><p><strong>4.2 线程的实现</strong></p><p>用户线程：在用户空间实现。<br>内核线程：在内核中实现。<br>轻量级进程：在内核中实现，支持用户线程。</p><p><strong>用户线程</strong></p><p>在<strong>用户空间</strong>实现的线程机制，它<strong>不依赖于</strong>操作系统的内核，由一组用户级的<strong>线程库函数</strong>来完成线程的管理，包括进程的创建，终止，同步和调度等。</p><p><img src="https://s2.loli.net/2023/04/05/I6O9D7CzwtoRSKB.jpg" alt="img"></p><p><strong>用户线程的缺点</strong></p><p>1.如果一个线程发起系统调用而阻塞，则<strong>整个进程在等待</strong>。<br>2.当一个线程开始运行后，除非它主动交出CPU的使用权，否则它所在的进程中的其他线程将无法运行。<br>3.由于时间片分配给进程，与其他进程比，在多线程执行时，每个<strong>线程得到的时间片较少</strong>，执行会较慢。</p><p><strong>内核线程</strong></p><p>在操作系统的<strong>内核当中</strong>实现的一种线程机制，由操作系统的内核来完成线程的创建、终止和管理。</p><p>由内核来维护PCB和TCB；线程的创建，终止和切换都是通过<strong>系统调用/内核函数</strong>的方式来进行的，由内核来完成，因此<strong>系统开销大</strong>。</p><p>在一个进程当中，如果某个内核线程发起系统调用而被阻塞，<strong>并不会影响</strong>其他内核线程的运行；时间片是<strong>以线程为单位分配的</strong>，多线程的进程<strong>获得更多的CPU时间</strong>；</p><p><strong>轻量级进程</strong></p><p>是内核支持的用户线程，一个进程可有一个或多个轻量级进程，每个轻量级进程由一个单独的内核线程来支持。</p><p><strong>4.3 上下文切换</strong></p><p>进程切换时，需要存储什么上下文？<br>寄存器（PC，SP等）CPU状态。<strong>进程切换的过程</strong>是将被切换的进程会将信息保存在PCB中，把另一个进程中的PCB信息恢复到CPU中。</p><h2 id="五、进程控制"><a href="#五、进程控制" class="headerlink" title="五、进程控制"></a>五、进程控制</h2><p>简单说一下和进程相关的一些系统调用。</p><p><strong>5.1 创建进程</strong></p><p>在系统中，出现了创建新进程的请求后，OS就调用进程创建原语Creat，经过下面的步骤：<br>1.申请空白PCB，获得唯一标识，从PCB集合中获取空白PCB。<br>2.为新进程分配所需资源。<br>3.初始化进程控制块<br>4.如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。</p><p><strong>5.2 加载和执行进程</strong></p><p><strong>fork()函数的简单实现</strong>：<br>对子进程分配内存；<br>复制父进程的内存和CPU寄存器到子进程里。</p><p><strong>缺点</strong><br>在fork()之后，几乎都要<strong>调用exec()<strong>，导致fork()操作中</strong>内存复制是没有作用的</strong>，而且子进程将可能关闭打开的文件和连接，<strong>开销昂贵</strong>。</p><p><strong>vfork()函数的简单实现：</strong><br>1.一个创建进程的系统调用，<strong>不需要</strong>创建一个同样的内存映像，只复制和当前地址空间相关的元数据，页表等。<br>2.使用<strong>copy on write</strong>技术，只有当对某个地址<strong>写操作</strong>的时候才会<strong>触发异常</strong>，将触发异常的页分成两份，让父进程和子进程分别拥有不同的地址。</p><p><strong>5.3 等待和终止进程</strong></p><p><strong>wait()函数</strong></p><p>**wait()**系统调用是被父进程用来等待子进程的结束。</p><p>为什么要让父进程使用wait()来等待子进程结束？<br>因为子进程的结束只能<strong>释放用户空间</strong>所占用的内存，他的<strong>PCB</strong>是存放在<strong>内核中</strong>的，用户空间释放完，<strong>无法进行</strong>系统调用删除PCB。所以需要<strong>父进程帮助</strong>它在内核中删除。</p><p><strong>exit()函数</strong></p><p>进程结束执行后，它调用exit()，操作系统<strong>解锁父进程</strong>，并且将通过exit()传递得到的返回值为wait()调用的结果 。</p><p>调用exit()后，会发生什么？<br>会将程序结果作为一个参数；关闭打开的文件，连接等；释放内存；释放大部分支持进程的操作系统结构；检查是否父进程是存活。</p><p>当子进程执行完exec()后还<strong>没返回给wait()<strong>回收PCB时，这一阶段，子进程处于</strong>僵尸态</strong>，也叫僵尸进程。</p><p>操作系统<strong>如何处理这些僵尸进程</strong>的？<br>如果父进程先于子进程死亡，将没有进程等待子进程释放。Init进程会定期扫描PCB列表，如果有进程处于僵尸态就会代替父进程进行wait()。</p><p><img src="https://s2.loli.net/2023/04/05/j38nfOAJcBSklEp.jpg" alt="img"></p><h2 id="六、处理机-CPU调度"><a href="#六、处理机-CPU调度" class="headerlink" title="六、处理机/CPU调度"></a>六、处理机/CPU调度</h2><p>首先来看看为什么需要对进程进行调度呢？进程的上下文切换是需要开销的，当然希望越少触发越好，为什么不能让进程一个个运行，节约这个开销，换句话说，调度算法存在的意义是什么呢？</p><p>为了让系统的效率更高，<strong>满足一些特定的需求</strong>，比如实时性，优先级更高的任务。在调度的过程中，前面的进程可能由于某些原因，处于阻塞状态，如进行IO操作读取文件时<strong>CPU的利用率</strong>较低，此时不进行切换，会导致资源的浪费，效率不高。</p><p><strong>6.1 进程调度的方式</strong></p><p>对于用户态进程来说：<br><strong>不可抢占式</strong><br>调度进程必须等待事件结束。</p><p><strong>可以抢占式</strong><br>允许调度程序根据某种原则，<strong>暂停</strong>某个正在执行的进程，将已分配给该进程的处理机<strong>重新分配</strong>给另一进程。</p><p><strong>6.2 衡量调度算法的指标</strong></p><p><strong>吞吐量</strong><br>在单位时间内完成的进程数量（操作系统的计算带宽）。</p><p><strong>周转时间</strong><br>一个进程从初始化到结束，包括所有等待时间所花费的时间。</p><p><strong>等待时间</strong><br>进程在就绪队列中的总时间。</p><p><strong>响应时间</strong><br>从一个请求被提交到产生第一次响应所花费的总时间（操作系统的计算延迟）。</p><p><strong>6.3 基本调度算法</strong></p><ul><li>FCFS（先来先服务）</li><li>SJF（短进程优先）</li><li>HRRN（最高响应时间比优先）</li><li>RR（轮询）</li><li>MFQ（多级反馈队列）</li><li>FSS（公平共享调度）</li></ul><p><strong>FCFS</strong>（First-Come First-Served，先来先服务）</p><p>思路<br>处理机按照任务到达的顺序来调度。如果进程在执行中阻塞，队列中的下一个会得到CPU。</p><p>优点<br>实现简单。</p><p>缺点<br>1.平均等待时间波动较大。受制于前面执行之间较长的进程。<br>2.花费时间少的任务可能排在花费时间长的任务后面。<br>3.可能导致IO和CPU之间的重叠处理：CPU密集型进程会导致IO设备闲置时，IO密集型进程也在等待。</p><p><strong>SJF</strong>（Short Job First，短进程优先）</p><p>思路<br>将执行时间短的先执行。<br>注：这种算法可以是抢占也可以是不抢占的。当CPU执行时，发现新来的进程处理时间更短。如果是非抢占式则排到队列的第一个；如果是抢占式则将当前的进程转换为就绪态，自己接受CPU的执行。</p><p>优点<br>当短作业占有很大比例时，能使他们能比长作业更优先执行；<br>平均等待时间最小，平均周转时间最小。</p><p>缺点<br>1.可能导致饥饿：连续的段任务会让长任务饥饿；短任务可用时的任何长任务的CPU时间都会增加平均等待时间。<br>2.需要预知未来，估算作业的运行时间。<br>3.不能保证紧迫性作业能得到即时处理。</p><p><strong>HRRN</strong>（Highest Response Ratio Next，最高响应时间比优先）</p><p>思路<br>关注进程等待了多长时间，防止无限期推迟。相当于总和考虑进程的执行时间和等待时间。不可抢占。<br>R=（w+s）/s<br>R：响应时间比<br>w：等待时间<br>s：执行时间<br>选择R值最高的进程。</p><p><strong>RR</strong>（Round Robin，轮询）</p><p>思路<br>让每个进程在就绪队列中的等待时间与享受服务的时间成正比例。<br>1.系统根据<strong>FCFS策略</strong>将所有进程排成一个就绪队列，<strong>设置一定时间</strong>产生一次中断。<br>2.激活系统中的进程调度程序，完成一次调度。每次中断后都将CPU分配给<strong>队首进程</strong>。</p><p>时间片大小的设定</p><p>如果选<strong>很小</strong>，则有利于短作业，但会频繁地进行<strong>上下文切换</strong>，增加系统开销；如果<strong>很长</strong>，为使每个进程都能在一个时间片内完成，就<strong>退化为FCFS算法</strong>。<br>一般取<strong>略大于一次典型交互所需时间</strong>，使大多数交互式进程能在一个时间片内完成。</p><p><strong>MFQ</strong>（Multileved Feedback Queue，多级反馈队列）</p><p>思路<br>设有n级优先级，一个进程可以在不同的队列中移动。</p><p>优先级变化条件<br>调度的时间片大小随优先级<strong>增加而减小</strong>；<br>如果任务在当前的时间片中没有完成，则<strong>降到下一个优先级</strong>。</p><p>过程<br>（1）设置多个就绪队列，为每个队列<strong>分配不同优先级</strong>，优先级越高，时间片越小。第一队列优先级最高，第二次之，以此类推。<br>（2）每个队列都采用FCFS算法。当新进程进入内存后，就放在<strong>队尾</strong>。当第一个时间片中<strong>没有完成</strong>，就<strong>放入第二队列</strong>的队尾，以此类推。最终放到第n队列后会用<strong>RR方式调度</strong>。<br>（3）按队列优先级调度程序。当<strong>第一队列为空时</strong>，才调度第二队列。</p><p>优点<br>CPU密集型任务的优先级下降很快；<br>达到IO密集型的进程优先级高。</p><p><strong>FSS</strong>（Fair Share Scheduling，公平共享调度）</p><p>思路<br>保证每个进程都获得相同的处理机时间。一般用来控制用户对系统资源的访问。</p><p>优点<br>1.保证不重要的进程无法垄断资源。<br>2.未使用的资源按照每个组所分配的资源比例来分配。<br>3.没有达到资源使用率目标的进程获得更高的优先级。</p><p><strong>6.4 实时调度算法</strong></p><p>实时调度算法主要面向一些实时控制系统。<br><strong>强实时系统HRT</strong> (Hard Real-time)<br>需要在保证的时间内完成重要的任务，<strong>必须完成</strong>。如果错过了最后期限，可能会引发灾难性的后果。</p><p><strong>弱实时系统SRT</strong>(Soft Real-time)<br>要求重要的进程的优先级更高，<strong>尽量完成</strong>，并非必须。如果没被满足，就相应地降低要求。</p><p>在实时系统中，对于不同性质的实时任务，HRT和SRT。都会联系着一个截止时间。为保证任务的进程，实时调度必须能满足实时任务对截止时间的要求。</p><p><strong>RM</strong>（Rate Monotonic，速率单调调度）</p><p>是最佳<strong>静态优先级</strong>调度（在调度之前就确定优先级），通过周期安排优先级，<strong>周期越短优先级越高</strong>，执行周期最短的任务。</p><p><strong>EDF</strong>（Earliest Deadline First，最早期限调度）</p><p>根据任务的<strong>截止时间</strong>来确定优先级，deadline越早优先级越高，具有最佳的动态优先级调度（在任务的执行过程中，优先级会发生变化）。每次执行deadline最早的任务。</p><p><strong>6.5 优先级反转</strong></p><p><img src="https://s2.loli.net/2023/04/05/4ec8C3JuRw9VPqU.jpg" alt="img"></p><p>首先看一下这个图中反应的问题，优先级T1&gt;T2&gt;T3。T3先执行，当时间为t3时，T1开始执行，当到t4时，T1需要T3占用的共享资源，由于T3没有释放，就先进入阻塞状态。当时间为t5时，T2由于优先级高，开始执行导致T1的等待时间取决于T2的长度。</p><p>可以设置优先级天花板来解决这个等待问题。</p><p><strong>设置优先级天花板</strong><br>让资源的优先级和“所有可以锁定该资源的任务中优先级最高的那个任务”的优先级相同。</p><p>除非<strong>优先级高于</strong>系统中<strong>所有</strong>被锁定的资源的<strong>优先级上限</strong>，否则任务尝试执行临界区的时候会被阻塞。持有<strong>最高优先级</strong>的上限信号量锁的任务，会<strong>继承</strong>被该锁所阻塞的任务的优先级。</p><p>因此利用优先级继承，当T3占有共享资源并T1想访问时，可以将T3的优先级进行动态的提升与T1一致，此时T2进程就不会打断T3的执行。</p><h2 id="七、同步-amp-互斥"><a href="#七、同步-amp-互斥" class="headerlink" title="七、同步&amp;互斥"></a>七、同步&amp;互斥</h2><p><strong>7.1 概念引入</strong></p><p><strong>发现问题</strong><br>对于某些功能的实现上往往由于进程上下文切换而导致共享资源的操作不一致的问题。从而引发系统缺陷，让程序结果依赖于并发执行或事件的顺序/事件。</p><p>我们会发现，有时候，操作系统需要对临界区资源保护，采用<strong>互斥机制</strong>来实现同一时刻，只有一个或n个进程能对进行访问。还有时，操作系统还需要<strong>同步机制</strong>来保证一定的进程协作执行顺序。而同步和互斥又可以基于<strong>原子操作</strong>来实现。</p><p>在说同步和互斥的手段之前，先要了解几个概念~</p><p><strong>原子操作-Atomic Operation</strong><br>注：原子操作是指一次不存在任何中断或者失败的执行。</p><p><strong>临界区</strong><br>临界区是指进程中的一段需要访问共享资源并且当另一个进程处于响应代码区域时便不会被执行的代码区域。</p><p><strong>同步</strong><br>某些程序为了完成某任务而建立多个进程，这些进程为了完成一项任务而相互合作，在某些位置上协调他们的工作次序，传递信息。同步源于合作。</p><p><strong>互斥</strong><br>当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源。</p><p>在实现上，应该考虑的一些原则：<br><strong>空闲让进</strong><br>当临界区空闲时，允许一个请求进入临界区的进程进入临界区。</p><p><strong>忙则等待</strong><br>当临界区正在被访问时，试图进入临界区的其他资源应该等待。保持对临界区的互斥访问。</p><p><strong>有限等待</strong><br>如果一个线程处于入口，那么在其请求被接受之前，其他线程进入临界区的事件是有限制的。</p><p><strong>无忙等待</strong><br>如果一个进程在等待进入临界区，那么在它可以进入之前会被挂起。</p><p>实现互斥的方法有<strong>基于硬件</strong>和<strong>基于软件</strong>的解决方案。</p><p><strong>7.2 基于硬件的解决方案</strong></p><p><strong>7.2.1 禁用硬件中断</strong></p><p>让硬件将中断处理延迟到中断启用后。在临界区内，没有中断，没有上下文切换，因此没有并发。</p><p><strong>思路</strong><br>进入临界区；禁用中断。离开临界区；开启中断。</p><p><strong>缺点</strong><br>一旦中断禁止，线程无法被停止；<br>无法限制响应中断所需的时间。</p><p><strong>7.2.2 利用Test-and-Set</strong></p><p>这是一条硬件指令-测试并建立。</p><p><strong>思路</strong><br>进入临界区之前，首先用TS指令测试lock，如果为false，则表示空闲，将lock赋为true，关闭临界资源；如果TestAndSet返回true，则一直循环测试，直到返回false，跳出循环，进入临界区。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean <span class="title function_">TestAndSet</span><span class="params">(boolean *lock)</span>{</span><br><span class="line">   boolean old=*lock;</span><br><span class="line">   *lock=TRUE;</span><br><span class="line">   <span class="keyword">return</span> old;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注：整个方法可以看成一条硬件指令，原子操作。<br>基于这个指令，我们可以实现获取资源和释放资源的操作。</p><p><strong>获取资源</strong><br>在进入临界区之前，先获取资源。<br>acquire()<br>{<br>while(TestAndSet(*lock))；<br>}<br>进入临界区后，对临界区进行操作…</p><p><strong>解释</strong><br>当<em>lock为<strong>false</strong>，说明临界区<strong>空闲</strong>，则跳出while循环，进入临界区。<br>当</em>lock为<strong>true</strong>，说明临界区有<strong>正在被使用</strong>，则继续在循环内（忙等），直到临界区空闲，才会跳出。</p><p><strong>释放资源</strong><br>退出临界区之前，应先释放资源。<br>release()<br>{<br>*lock=FALSE；<br>}<br>*lock=FALSE表示临界区空闲，其他进程可以抢占临界区。</p><p><strong>思考</strong><br>有一个问题，进程在忙等时是会占用CPU的，如何设计一个方案让资源得到合理的应用？可以用一个等待队列，当获取不到时，可以将其PCB放到等待队列中，让出CPU；当有进程release后，唤醒等待队列中的PCB。当上下文开销大于临界区操作时间时，选择忙等实现；反之，采用等待队列的方式实现。</p><p><strong>7.2.3 交换</strong></p><p>同样，也可以看成一条硬件指令~</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Exchange</span><span class="params">(boolean *a,boolean *b)</span>{</span><br><span class="line">   boolean temp=*a;</span><br><span class="line">   *a=*b;</span><br><span class="line">   *b=temp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>思路</strong><br>1.设置全局变量，int lock=0；<br>2.每个进程设置局部变量int key=1；<br>3.每次对于临界区的操作将执行如下代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> key;</span><br><span class="line"><span class="keyword">do</span>{</span><br><span class="line">    key=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(key==<span class="number">1</span>) Exchange(lock,key);</span><br><span class="line">    <span class="comment">//进入临界区</span></span><br><span class="line">    lock=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//退出临界区</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>解释</strong><br>初始化后，lock=0，key=1，临界区空闲；循环执行Exchange，当lock==0，key==1时，获得资源，进入临界区；出去后将lock置为0。<br>当lock=1，key=1时，说明临界区被占用，将永远不可能退出循环，直到获取锁标记。</p><p><strong>优点</strong><br>1.简单。<br>2.适用于单处理器或共享主存的多处理器中。<br>3.可以用于支持多临界区。</p><p><strong>缺点</strong><br>忙等消耗CPU开销；<br>当进程离开临界区并且多个进程在等待的时候可能导致饥饿。</p><p><strong>7.3 基于软件的解决方案</strong></p><p>算法是挺多的，这里就简单的介绍两个。</p><p><strong>7.3.1 Dekker算法</strong></p><p>是第一个针对双线程例子的正确解决方案，基于两个进程的情况下。</p><p><strong>思路</strong><br>首先定义了<br>int turn：指示该谁进入临界区。<br>boolean flag[]：指示进程是否准备好进入临界区。</p><p><strong>进入临界区</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flag[i]=TRUE;</span><br><span class="line"><span class="comment">//表示其他进程</span></span><br><span class="line">turn=j;</span><br><span class="line"><span class="keyword">while</span>(flag[j]&amp;&amp;turn==j);</span><br></pre></td></tr></tbody></table></figure><p><strong>解释</strong><br>前提条件是只有i，j两个进程。刚开始，flag[i]=TRUE表示i想占用临界区，而turn=j表示临界区正在被j占用。只有当j不想占用临界区并且已经退出时，i才能占用。</p><p><strong>退出临界区</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flag[i]=FALSE;</span><br><span class="line"><span class="keyword">do</span>{</span><br><span class="line">   flag[i]=TRUE;</span><br><span class="line">   turn=j;</span><br><span class="line">    <span class="keyword">while</span>(flag[j]&amp;&amp;turn==j);</span><br><span class="line">      <span class="comment">//在临界区中操作...</span></span><br><span class="line">      flag[i]=FALSE;</span><br><span class="line">     <span class="comment">//退出临界区</span></span><br><span class="line">}<span class="keyword">while</span>(TRUE)</span><br></pre></td></tr></tbody></table></figure><p><strong>解释</strong><br>退出时只需要flag[i]=FALSE即可。没有占用的意愿后，进程j就能直接进入了。</p><p><strong>7.3.2 Bakery算法</strong></p><p>是对于N个进程的临界区的解决方案。</p><p><strong>思路</strong><br>1.进入临界区之前，进程接收一个数字。<br>2.得到的数字最小的进入临界区。<br>3.如果两个进程收到相同的数字，则比较进程的pid小的先进入临界区。<br>4.编号方案是按照美剧的增加顺序生成数字。</p><p><strong>缺点</strong><br>1.复杂，需要两个进程间的共享数据项。<br>2.需要忙等，浪费CPU。<br>3.没有硬件的保证下，无真正的软件解决方案（需要LOAD和STORE支持）。</p><h2 id="八、信号量与管程"><a href="#八、信号量与管程" class="headerlink" title="八、信号量与管程"></a>八、信号量与管程</h2><p>对于临界区的控制，我们可以采用一些互斥手段来保证同时只有1个进程在操作共享资源，但有时候，需要限制进入临界区的进程个数。此时就要同步的手段去保证，实现同步的方法有<strong>信号量机制</strong>和<strong>管程</strong>。</p><p><strong>8.1 信号量机制</strong></p><p>首先要清楚，信号量机制可以实现互斥和条件同步（一个线程等待另一个线程的事件发生）。信号量分为整型，记录型和AND型信号量。下面主要用<strong>记录型信号量</strong>进行实现。</p><p><strong>实现原理（伪代码）</strong><br>定义一个整型（sem）和两个原子操作。如果要实现同步，则要加入一个等待队列（仅用于互斥就不用啦）。下面讲实现同步的思路：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Semaphore</span>{</span><br><span class="line">   <span class="type">int</span> sem=n;</span><br><span class="line">   WaitQueue q;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>sem初始化为资源数。当有线程期望获取资源，则将sem–。<br>p()：获取资源。sem–；如果sem&lt;0，则将当前线程放到等待队列中，阻塞当前线程。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p(){</span><br><span class="line">  sem--;</span><br><span class="line">  <span class="keyword">if</span>(sem&lt;<span class="number">0</span>){</span><br><span class="line">    add currentThread to q;</span><br><span class="line">    block currentThread;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>v()：释放资源。sem++；如果sem&lt;=0，则从等待队列中取出并唤醒线程。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v(){</span><br><span class="line">  sem++;</span><br><span class="line">  <span class="keyword">if</span>(sem&lt;=<span class="number">0</span>){</span><br><span class="line">    remove a thread from q;</span><br><span class="line">    wakeup a thread;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注：PV操作都必须是原子操作。</p><p><strong>用信号量解决有界缓冲区的生产者-消费者问题</strong></p><p><strong>前提</strong><br>1.在任何时刻只有一个线程操作缓冲区（互斥）<br>2.当缓冲区为空，消费者必须等待生产者（同步）<br>3.缓冲区满，生产者必须等待消费者（同步）</p><p><strong>使用三个信号量：</strong></p><ul><li>二进制信号量mutex互斥</li><li>一般信号量fullBuffers</li><li>一般信号量emptyBuffers</li></ul><p>伪代码实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span>{</span><br><span class="line">  Semaphore mutex=<span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//表示刚开始，buffer是空的</span></span><br><span class="line">  Semaphore fullBuffers=<span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//表示buffer的空间为n</span></span><br><span class="line">  Semaphore emptyBuffers=<span class="keyword">new</span> <span class="title class_">Semaphore</span>(n);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>生产者</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保证缓冲区不要溢出</span></span><br><span class="line">emptyBuffers.p();</span><br><span class="line">mutex.p();</span><br><span class="line">add to buffer;</span><br><span class="line">mutex.v();</span><br><span class="line"><span class="comment">//唤醒阻塞的消费者</span></span><br><span class="line">fullBuffers.v();</span><br></pre></td></tr></tbody></table></figure><p>解释<br>对于缓冲区的操作，必须是用<strong>互斥信号量</strong>，保证同一时刻<strong>只有一个线程</strong>进入临界区。生产者刚开始需要判断，如果不满足emptyBuffers的状态就会被<strong>阻塞</strong>。当往缓冲区中放入数据后，需要<strong>唤醒</strong>等待在fullBuffer状态的消费者线程。</p><p><strong>消费者</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保证缓冲区有数据才能取</span></span><br><span class="line">fullBuffers.p();</span><br><span class="line">mutex.p();</span><br><span class="line">remove from buffer;</span><br><span class="line">mutex.v();</span><br><span class="line"><span class="comment">//唤醒阻塞的生产者</span></span><br><span class="line">emptyBuffers.v();</span><br></pre></td></tr></tbody></table></figure><p>解释<br>消费者需要先判断，缓冲区<strong>是否有数据</strong>，如果没有则不满足fullBuffers状态而被<strong>挂起</strong>。当消费数据后就可以<strong>唤醒</strong>阻塞在emptyBuffers的生产者了。</p><p><strong>信号量机制的缺点</strong><br>1.读/开发代码比较困难。<br>2.容易出错，使用的信号量被另一个线程占用，忘记释放。<br>3.不能处理死锁问题。</p><p><strong>8.2 管程</strong></p><p>在信号量机制下，每个要访问临界资源的进程都必须调用PV操作。使大量的同步操作分散在各个进程中，不便于同一的管理，也容易产生死锁。管程的出现就是为了<strong>分离互斥和条件同步的关注</strong>。</p><p><strong>定义</strong><br>先简单介绍其定义，代表共享资源的数据结构以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序共同构成了一个操作系统的资源管理模块。简单来说就是<strong>管程=共享资源数据结构+对数据结构的操作。</strong><br>利用少量的共享数据结构抽象的表示系统中共享资源，并且讲对该共享数据结构的特定操作定义为一组过程。对于共享资源的访问必须通过这组过程，每次只有一个进程进入管程。</p><p><img src="https://s2.loli.net/2023/04/05/NaHgFEGC5s2pVML.jpg" alt="img"></p><p>管程的组成</p><p>在<strong>管程的设计</strong>中包含：<br>1个锁：指定临界区。来保证同一时刻只有一个线程访问管程。<br>0或多个条件变量：等待/通知信号量用于管理并发访问共享数据。</p><p>注：Java中的ReentrantLock就是基于管程的思想实现的。具体实现可以看我以前些的文章。</p><p><strong>实现思路</strong><br>进入管程需要<strong>获得lock</strong>，要维护lock的<strong>等待队列</strong>。如果某个资源得不到满足就会<strong>挂到某个条件变量</strong>中进行wait并<strong>释放锁</strong>。当某个条件满足时，会调用某个条件变量的signal，<strong>唤醒</strong>等待在该条件变量上的线程。</p><p><strong>实现原理（伪代码）</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Condition</span>{</span><br><span class="line">   <span class="type">int</span> numWaiting=<span class="number">0</span>;</span><br><span class="line">   WaitingQueue q;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>numWaiting是等待在该Condition上的线程数量。q是等待队列，可以由链表实现。<br>wait(lock)：将等待线程数+1并添加到等待队列中，此时释放锁，阻塞当前线程，获取锁。为什么要释放锁再获取锁，后序再解释。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wait(lock){</span><br><span class="line">  numWaiting++;</span><br><span class="line">  add <span class="built_in">this</span> thread to q;</span><br><span class="line">  release(lock);</span><br><span class="line">  block current thread;</span><br><span class="line">  require(lock);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>signal()：当等待线程数&gt;0时，才会唤醒对应的线程。这里可以先解释wait()中为什么要require(lock)。当某个wait的线程被唤醒后，需要先获得锁，才能进入管程。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">signal(){</span><br><span class="line">  <span class="keyword">if</span>(numWaiting&gt;<span class="number">0</span>){</span><br><span class="line">    remove a thread t from q;</span><br><span class="line">    wakeup(t);</span><br><span class="line">    numWaiting--;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注：wait和signal必须是原子操作。</p><p><strong>用管程解决有界缓冲区的生产者-消费者问题</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span>{</span><br><span class="line">  Lock lock;</span><br><span class="line">  <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">  Condition notFull,notEmpty;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>lock是进入管程前需要获取的对象，count表示多少线程在缓冲区中。</p><p><strong>生产者</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock.acquire();</span><br><span class="line"><span class="keyword">while</span>(count==n) notFull.wait(&amp;lock);</span><br><span class="line">add c to the buffer;</span><br><span class="line">count++;</span><br><span class="line">notEmpty.signal();</span><br><span class="line">lock.release();</span><br></pre></td></tr></tbody></table></figure><p>解释<br>操作管程前，要先获取锁。然后保证缓冲区不为满，满了则阻塞。将数据放入缓冲区后，需要唤醒消费者来取，最终释放资源。</p><p><strong>消费者</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock.acquire();</span><br><span class="line"><span class="keyword">while</span>(count==<span class="number">0</span>) notEmpty.wait(&amp;lock);</span><br><span class="line">remove c from buffer;</span><br><span class="line">coutn--;</span><br><span class="line">notFull.signal();</span><br><span class="line">lock.release();</span><br></pre></td></tr></tbody></table></figure><p>解释<br>获得锁进入管程，当缓冲区没有数据时，等待生产者添加。成功取出后，唤醒阻塞生产者来放数据，然后释放资源。</p><p><strong>思考</strong><br><strong>生产者的实现</strong>与<strong>信号量的解决方案</strong>相比，为什么获取释放锁要放在<strong>头和尾</strong>？<br>因为要保证在管程内只有<strong>一个线程</strong>，才能正常调用管程的一些操作。</p><p>为什么wait里要有release(lock)的操作？<br>在生产者中调用wait，如果不释放，会导致<strong>所有想要进入管程的线程都在等待</strong>。</p><h2 id="九、进程间通信的方式"><a href="#九、进程间通信的方式" class="headerlink" title="九、进程间通信的方式"></a>九、进程间通信的方式</h2><p>可以分为直接通信和间接通信。</p><p><strong>直接通信</strong></p><p>进程必须正确的命名对方，必须有明确的发送方，message，接收方。</p><p>通信链路的属性<br>1.自动建立链路<br>2.一条链路恰好对应一对通信进程<br>3.每对进程之间只有一个链接存在<br>4.链接可以是单项的，但通常为双向</p><p><strong>间接通信</strong></p><p>进程定向地从消息队列接收消息，每个消息都有一个唯一的ID，只有他们共享了一个消息队列，进程才能通信。</p><p>通信链路的属性<br>1.只有进程共享一个共同的消息队列，才建立链路<br>2.链路可以与许多进程相关联<br>3.每对进程可以共享多个通信链路<br>4.连接可以是单向或双向的</p><p>具体的通信方式有<strong>信号，管道，消息队列，共享内存</strong>。下面简单介绍一下四种通信方式。</p><p><strong>9.1 信号</strong></p><p>是软件通过系统调用，以软件中断通知事件处理。</p><p><strong>应用程序对信号的处理方式</strong></p><ul><li>catch：指定信号处理函数被调用</li><li>ignore：依靠操作系统的默认处理</li><li>mask：闭塞信号因此不会传送</li></ul><p>缺点<br>只能传递信号，不能传输要交换的任何数据。</p><p>优点<br>效率高。</p><p><strong>实现原理</strong></p><p><img src="https://s2.loli.net/2023/04/05/5bITMglQ2DYsVSv.webp" alt="img"></p><p>图片来源于网络</p><p>1）应用程序<strong>注册</strong>处理信号的handles，进行系统调用，由用户态切换到内核态。<br>2）内核处理信号，返回时通过<strong>改变栈指针</strong>，将返回点从系统调用的后一条语句改成信号处理函数的入口并<strong>分发给handler</strong>。<br>3）处理完毕再将栈指针指向调用系统调用的<strong>后一条语句。</strong></p><p><strong>9.2 管道</strong></p><p>管道用于数据交换，是用于连接一个读进程和写进程以实现他们呢之间通信的一个共享文件。<br>进程不知道是从键盘，文件还是程序读写到终端，文件程序。</p><p>指令<strong>ls|more的shell实现方式</strong>：<br>shell创建<strong>两个子进程</strong>，ls和more。子进程<strong>共享</strong>父进程的<strong>文件描述符</strong>，ls<strong>输出到管道上</strong>，more从<strong>管道中取数据</strong>；当ls发现管道中已经<strong>满了</strong>或more发现管道中<strong>没有数据</strong>的就会<strong>阻塞</strong>。</p><p><strong>9.3 消息队列</strong></p><p>也是一种数据传输机制，以<strong>格式化的message</strong>（作为一个字节序列存储）为单位，将通信数据封装在消息中，并利用操作系统提供的一组通信命令（原语），完成消息传递与交互，按照FIFO来管理消息。</p><p>注：消息队列有直接通信方式和间接通信方式，上述为<strong>直接通信方式</strong>。而间接的是通过共享中间实体进行发送和接收。</p><p><strong>9.4 共享内存</strong></p><p>在每个进程的私有地址空间，中<strong>明确地设置</strong>了<strong>共享内存段</strong>。</p><p>优点<br>快速，方便地共享数据。</p><p>不足<br>必须依赖同步机制，同步数据访问。</p><blockquote><p>来自知乎<a href="https://zhuanlan.zhihu.com/p/88017448">操作系统（三）—进程管理 - 知乎 (zhihu.com)</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统导论——虚拟化</title>
      <link href="/2023/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是虚拟化"><a href="#什么是虚拟化" class="headerlink" title="什么是虚拟化?"></a>什么是虚拟化?</h2><p>虚拟化，是指通过虚拟化技术将一台计算机虚拟为多台逻辑计算机。在一台计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。  </p><blockquote><ul><li>操作系统将物理（physical）资源（如处理器、内存或磁盘）转换为更通用、更强大且更易于使用的虚拟形式</li><li>虚拟化让许多程序运行（从而共享 CPU），让许多程序可以同时访问自己的指令和数据（从而共享内存），让许多程序访问设备（从而共享磁盘等），所以操作系统有时被称为资源操理器（resource manager）——操作系统导论</li></ul></blockquote><h3 id="虚拟化cpu"><a href="#虚拟化cpu" class="headerlink" title="虚拟化cpu"></a>虚拟化cpu</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/*这行代码使用了assert函数来确保程序的调用者提供了一个参数。如果 argc 不等于 2，即程序被调用时没有传入参数或传入了多个参数，assert函数会中止程序的执行并输出一条错误消息。如果 argc 等于2，即程序被调用时传入了一个参数，assert函数会使程序继续执行下去。在这个特定的程序中，argv[0] 包含了程序的名称，而 argv[1] 包含了第一个参数，因此需要确保 argc 的值为 2 才能正确获取命令行参数。*/</span></span><br><span class="line">    <span class="built_in">assert</span>(argc == <span class="number">2</span>);</span><br><span class="line">    <span class="type">char</span> *str = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*这个C程序接受一个命令行参数，并使用一个无限循环，每秒钟将其打印到控制台。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以下是程序逻辑的详细解释：</span></span><br><span class="line"><span class="comment">使用 assert 函数验证程序是否被调用时只传入了一个参数（程序名称本身被认为是第一个参数）。</span></span><br><span class="line"><span class="comment">第一个参数被存储在变量 str 中。</span></span><br><span class="line"><span class="comment">程序进入无限循环，使用 printf 连续将 str 的值打印到控制台。</span></span><br><span class="line"><span class="comment">使用 sleep 函数在每次循环迭代之间暂停程序1秒钟。</span></span><br><span class="line"><span class="comment">最后，main 函数返回0以表示成功执行。</span></span><br><span class="line"><span class="comment">需要注意的是，由于使用了一个无限循环，这个程序可能会一直运行直到手动终止或中断为止。*/</span></span><br></pre></td></tr></tbody></table></figure><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>这个程序是一个C程序，需要通过编译器将源代码编译成可执行文件后才能运行。下面是运行这个程序的步骤：</p><ol><li><p>将程序的源代码保存到一个文件中，例如 “cpu.c”。</p><p><code>touch cpu.c</code></p></li><li><p>安装一个C编译器，例如gcc。如果你使用的是Linux或MacOS操作系统，大多数发行版和版本都已经默认安装了gcc编译器。如果你使用的是Windows操作系统，可以安装MinGW或Cygwin来获得gcc编译器。</p></li><li><p>打开终端或命令提示符，并进入保存源代码的目录。</p></li><li><p>在终端或命令提示符中输入以下命令来编译程序：</p></li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o cpu cpu.c<span class="comment">//这将使用gcc编译器将源代码文件 "cpu.c" 编译成可执行文件 "cpu"。`</span></span><br></pre></td></tr></tbody></table></figure><ol start="5"><li>运行程序，输入以下命令：   </li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cpu<span class="comment">//这将在终端或命令提示符中启动程序。</span></span><br></pre></td></tr></tbody></table></figure><p>请注意，如果程序需要命令行参数，则需要在运行程序时指定这些参数。例如，如果程序需要一个字符串参数，则可以使用以下命令来运行程序：  </p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./<span class="string">"A"</span><span class="comment">//这将向程序传递一个字符串参数 "A"。</span></span><br></pre></td></tr></tbody></table></figure><h4 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h4><p>使用 <code>ps</code> 命令来查找程序的进程号（PID），然后使用 <code>kill</code> 命令来停止程序的执行。具体来说，可以使用以下命令来查找程序的进程号：</p><p><code>ps -ef | grep cpu</code></p><p>这将输出包含程序进程信息的行，其中第二列是进程号（PID）。</p><img src="https://s2.loli.net/2023/04/02/87DOW2vQACKenEm.png">]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>临界区与临界资源</title>
      <link href="/2023/04/02/%E4%B8%B4%E7%95%8C%E5%8C%BA%E5%92%8C%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90/"/>
      <url>/2023/04/02/%E4%B8%B4%E7%95%8C%E5%8C%BA%E5%92%8C%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h2 id="临界区和临界资源"><a href="#临界区和临界资源" class="headerlink" title="临界区和临界资源"></a>临界区和临界资源</h2><h3 id="1、临界资源"><a href="#1、临界资源" class="headerlink" title="1、临界资源"></a>1、临界资源</h3><p>概念：一次仅允许一个进程使用的共享资源。</p><h3 id="2、临界区"><a href="#2、临界区" class="headerlink" title="2、临界区"></a>2、临界区</h3><p>概念：每个进程中访问临界资源的那段程序称之为临界区。<br>临界区不是内核对象，而是系统提供的一种数据结构，程序中可以声明一个该类型的变量，之后用它来实现对资源的互斥访问。当欲访问某一临界资源时，先将该临界区加锁（若临界区不空闲则等待），用完该资源后，将临界区释放。<br>补充（待定）：分类：临界区也是代码的称呼，所以一个进程可能有多个临界区，分别用来访问不同的临界资源。<br>内核程序临界资源：系统时钟<br>普通临界资源：普通I/O设备，如打印机（进程访问这些资源的时候，很慢，会自动阻塞，等待资源使用完成）</p><blockquote><h4 id="另一种解释"><a href="#另一种解释" class="headerlink" title="另一种解释"></a>另一种解释</h4><p>1.临界资源<br>  临界资源是一次仅允许一个进程使用的共享资源。各进程采取互斥的方式，实现共享的资源称作临界资源。属于临界资源的硬件有，打印机，磁带机等；软件有消息队列，变量，数组，缓冲区等。诸进程间采取互斥方式，实现对这种资源的共享。</p><p>2.临界区：<br>  每个进程中访问临界资源的那段代码称为临界区（criticalsection），每次只允许一个进程进入临界区，进入后，不允许其他进程进入。不论是硬件临界资源还是软件临界资源，多个进程必须互斥的对它进行访问。多个进程涉及到同一个临界资源的的临界区称为相关临界区。使用临界区时，一般不允许其运行时间过长，只要运行在临界区的线程还没有离开，其他所有进入此临界区的线程都会被挂起而进入等待状态，并在一定程度上影响程序的运行性能。</p></blockquote><h3 id="3、进程进入临界区的调度原则"><a href="#3、进程进入临界区的调度原则" class="headerlink" title="3、进程进入临界区的调度原则"></a>3、进程进入临界区的调度原则</h3><ol><li>如果有若干进程请求进入空闲的临界区（空闲即0进程访问），一次仅允许一个进程进入。</li><li>任何时候，处于临界区内的进程不可多于一个（0 或 1），若已有进程进入自己的临界区，则其它想进入自己临界区的进程必须等待。</li><li>进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区。</li><li>如果其它进程不能进入自己的临界区，则应让出 CPU，避免进程出现 “忙等” 现象。</li></ol><blockquote><p>这里的自己指某个进程，其它进程指除了所说的某个进程之外的进程。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程</title>
      <link href="/2023/04/02/%E8%BF%9B%E7%A8%8B/"/>
      <url>/2023/04/02/%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概念提出"><a href="#概念提出" class="headerlink" title="概念提出"></a>概念提出</h2><p>进程是60年代初首先由<a href="https://baike.baidu.com/item/%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5%E5%AD%A6%E9%99%A2?fromModule=lemma_inlink">麻省理工学院</a>的<a href="https://baike.baidu.com/item/MULTICS%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">MULTICS系统</a>和IBM公司的<a href="https://baike.baidu.com/item/CTSS?fromModule=lemma_inlink">CTSS</a>/360系统引入的。 [2] </p><p>进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的<a href="https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81?fromModule=lemma_inlink">代码</a>，还包括当前的活动，通过<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8?fromModule=lemma_inlink">程序计数器</a>的值和处理<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8?fromModule=lemma_inlink">寄存器</a>的内容来表示。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>狭义定义：进程是正在运行的程序的实例（an instance of a computer program that is being executed）。</p><p>广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192?fromModule=lemma_inlink">操作系统</a>动态执行的<a href="https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83?fromModule=lemma_inlink">基本单元</a>，在传统的<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">操作系统</a>中，进程既是基本的<a href="https://baike.baidu.com/item/%E5%88%86%E9%85%8D%E5%8D%95%E5%85%83?fromModule=lemma_inlink">分配单元</a>，也是基本的执行单元。</p><p>进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括<a href="https://baike.baidu.com/item/%E6%96%87%E6%9C%AC?fromModule=lemma_inlink">文本</a>区域（text region）、数据区域（data region）和<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88?fromModule=lemma_inlink">堆栈</a>（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86?fromModule=lemma_inlink">处理</a>器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B?fromModule=lemma_inlink">进程</a>。 [3] </p><p>进程是操作系统中最基本、重要的概念。是多道程序系统出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律引进的一个概念,所有多道程序设计操作系统都建立在进程的基础上。</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>操作系统引入进程的概念的原因:</p><p>从理论角度看，是对正在运行的程序过程的抽象；</p><p>从实现角度看，是一种<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84?fromModule=lemma_inlink">数据结构</a>，目的在于清晰地刻画<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">动态系统</a>的内在规律，有效管理和调度进入<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">计算机系统</a><a href="https://baike.baidu.com/item/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8?fromModule=lemma_inlink">主存储器</a>运行的程序。</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>动态性：进程的实质是程序在<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">多道程序系统</a>中的一次执行过程，进程是动态产生，动态消亡的。</p><p>并发性：任何进程都可以同其他进程一起并发执行</p><p>独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位；</p><p><a href="https://baike.baidu.com/item/%E5%BC%82%E6%AD%A5%E6%80%A7?fromModule=lemma_inlink">异步性</a>：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进</p><p>结构特征：进程由程序、数据和<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97?fromModule=lemma_inlink">进程控制块</a>三部分组成。</p><p>多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果；但是执行过程中，程序不能发生改变。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>一个<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">计算机系统</a>进程包括（或者说“拥有”）下列数据：</p><p>那个程序的可运行<a href="https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E7%A0%81?fromModule=lemma_inlink">机器码</a>的一个在<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8?fromModule=lemma_inlink">存储器</a>的映像。 分配到的<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8?fromModule=lemma_inlink">存储器</a>（通常包括<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98?fromModule=lemma_inlink">虚拟内存</a>的一个区域）。<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8?fromModule=lemma_inlink">存储器</a>的内容包括可运行<a href="https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81?fromModule=lemma_inlink">代码</a>、特定于进程的数据（输入、输出）、调用<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88?fromModule=lemma_inlink">堆栈</a>、堆栈（用于保存运行时运数中途产生的数据）。 分配给该进程的资源的<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">操作系统</a>描述符，诸如文件描述符（<a href="https://baike.baidu.com/item/Unix?fromModule=lemma_inlink">Unix</a>术语）或<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84?fromModule=lemma_inlink">文件句柄</a>（Windows）、数据源和数据终端。 安全特性，诸如进程拥有者和进程的权限集（可以容许的操作）。 处理器状态（内文），诸如<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8?fromModule=lemma_inlink">寄存器</a>内容、<a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8%E5%99%A8?fromModule=lemma_inlink">物理存储器</a>寻址等。当进程正在运行时，状态通常储存在<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8?fromModule=lemma_inlink">寄存器</a>，其他<a href="https://baike.baidu.com/item/%E6%83%85%E5%86%B5?fromModule=lemma_inlink">情况</a>在<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8?fromModule=lemma_inlink">存储器</a>。</p><h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><p><a href="https://baike.baidu.com/pic/%E8%BF%9B%E7%A8%8B/382503/0/ac2fc3c459bc3aae38db4968?fr=lemma&amp;fromModule=lemma_content-image&amp;ct=single"><img src="https://s2.loli.net/2023/04/05/zMK1tTeCPG3BsiI.jpg" alt="Windows 和Windows Vista 体系结构"></a>Windows 和Windows Vista 体系结构</p><p>进行<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2?fromModule=lemma_inlink">进程切换</a>就是从正在运行的进程中收回<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E5%99%A8?fromModule=lemma_inlink">处理器</a>，然后再使待运行进程来占用<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E5%99%A8?fromModule=lemma_inlink">处理器</a>。</p><p>这里所说的从某个进程收回<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E5%99%A8?fromModule=lemma_inlink">处理器</a>，实质上就是把进程存放在处理器的<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8?fromModule=lemma_inlink">寄存器</a>中的中间数据找个地方存起来，从而把处理器的<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8?fromModule=lemma_inlink">寄存器</a>腾出来让其他进程使用。那么被中止运行进程的中间数据存在何处好呢？当然这个地方应该是进程的私有<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88?fromModule=lemma_inlink">堆栈</a>。</p><p>让进程来占用处理器，实质上是把某个进程存放在私有<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88?fromModule=lemma_inlink">堆栈</a>中<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8?fromModule=lemma_inlink">寄存器</a>的数据（前一次本进程被中止时的中间数据）再恢复到处理器的寄存器中去，并把待运行进程的<a href="https://baike.baidu.com/item/%E6%96%AD%E7%82%B9?fromModule=lemma_inlink">断点</a>送入处理器的程序<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88?fromModule=lemma_inlink">指针</a>PC，于是待运行进程就开始被处理器运行了，也就是这个进程已经占有处理器的使用权了。</p><p>这就像多个同学要分时使用同一张课桌一样，所谓要收回正在使用课桌同学的课桌使用权，实质上就是让他把属于他的东西拿走；而赋予某个同学课桌使用权，只不过就是让他把他的东西放到课桌上罢了。</p><p>在切换时，一个进程存储在处理器各<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8?fromModule=lemma_inlink">寄存器</a>中的中间数据叫做进程的上下文，所以进程的 切换实质上就是被中止运行进程与待运行<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87?fromModule=lemma_inlink">进程上下文</a>的切换。在进程未占用处理器时，进程 的上下文是存储在进程的私有<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88?fromModule=lemma_inlink">堆栈</a>中的。</p><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p><a href="https://baike.baidu.com/pic/%E8%BF%9B%E7%A8%8B/382503/0/d089b986cb94db6866096e7e?fr=lemma&amp;fromModule=lemma_content-image&amp;ct=single"><img src="https://s2.loli.net/2023/04/05/hf3yH41GNLxpcd5.jpg" alt="进程的三个基本状态"></a>进程的三个基本状态</p><p>进程执行时的间断性，决定了进程可能具有多种状态。事实上，运行中的进程可能具有以下三种基本状态。</p><p><strong>1）</strong><a href="https://baike.baidu.com/item/%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81?fromModule=lemma_inlink">就绪状态</a><strong>（Ready）：</strong></p><p>进程已获得除处理器外的所需<a href="https://baike.baidu.com/item/%E8%B5%84%E6%BA%90?fromModule=lemma_inlink">资源</a>，等待分配处理器资源；只要分配了处理器进程就可执行。就绪进程可以按多个<a href="https://baike.baidu.com/item/%E4%BC%98%E5%85%88%E7%BA%A7?fromModule=lemma_inlink">优先级</a>来划分<a href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97?fromModule=lemma_inlink">队列</a>。例如，当一个进程由于时间片用完而进入<a href="https://baike.baidu.com/item/%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81?fromModule=lemma_inlink">就绪状态</a>时，排入低<a href="https://baike.baidu.com/item/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97?fromModule=lemma_inlink">优先级队列</a>；当进程由<a href="https://baike.baidu.com/item/I%2FO%E6%93%8D%E4%BD%9C?fromModule=lemma_inlink">I/O操作</a>完成而进入<a href="https://baike.baidu.com/item/%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81?fromModule=lemma_inlink">就绪状态</a>时，排入高优先级队列。</p><p><strong>2）运行状态(Running)：</strong></p><p>进程占用处理器资源；处于此状态的进程的数目小于等于处理器的数目。在没有其他进程可以执行时(如所有进程都在<a href="https://baike.baidu.com/item/%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81?fromModule=lemma_inlink">阻塞状态</a>)，通常会自动执行系统的空闲进程。</p><p><strong>3）</strong><a href="https://baike.baidu.com/item/%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81?fromModule=lemma_inlink">阻塞状态</a>(<strong>Blocked</strong>)：</p><p>由于进程等待某种条件（如I/O操作或<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5?fromModule=lemma_inlink">进程同步</a>），在条件满足之前无法继续执行。该事件发生前即使把处理器资源分配给该进程，也无法运行。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><strong>程序</strong></p><p>程序是指令和数据的有序<a href="https://baike.baidu.com/item/%E9%9B%86%E5%90%88?fromModule=lemma_inlink">集合</a>，其本身没有任何运行的含义，是一个静态的概念。而进程是程序在<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA?fromModule=lemma_inlink">处理机</a>上的一次执行过程，它是一个动态的概念。</p><p>程序可以作为一种<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6?fromModule=lemma_inlink">软件</a>资料长期存在，而进程是有一定生命期的。程序是永久的，进程是暂时的。</p><p>进程更能真实地描述并发，而程序不能；</p><p>进程是由<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97?fromModule=lemma_inlink">进程控制块</a>、<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E6%AE%B5?fromModule=lemma_inlink">程序段</a>、数据段三部分组成;</p><p>进程具有创建其他进程的功能，而程序没有。</p><p>同一程序同时运行于若干个数据集合上，它将属于若干个不同的进程，也就是说同一程序可以对应多个进程。</p><p>在传统的<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">操作系统</a>中，程序并不能独立运行，作为资源分配和独立运行的<a href="https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83?fromModule=lemma_inlink">基本单元</a>都是进程。</p><p><strong>线程</strong></p><p><a href="https://baike.baidu.com/pic/%E8%BF%9B%E7%A8%8B/382503/0/f95898180b7961d14aedbcce?fr=lemma&amp;fromModule=lemma_content-image&amp;ct=single"><img src="https://s2.loli.net/2023/04/05/D6uN4rECdHTkFJp.jpg" alt="进程和线程关系"></a>进程和线程关系</p><p>通常在一个进程中可以包含若干个<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B?fromModule=lemma_inlink">线程</a>，它们可以利用进程所拥有的资源，在引入<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B?fromModule=lemma_inlink">线程</a>的<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">操作系统</a>中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B?fromModule=lemma_inlink">线程</a>比进程更小，基本上不拥有<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90?fromModule=lemma_inlink">系统资源</a>，故对它的调度所付出的开销就会小得多，能更高效的提高系统内多个程序间并发执行的程度。</p><p><strong>管程</strong></p><p>系统中的各种硬件资源和软件资源,均可用数据结构抽象地描述其资源特性,即用少量信息和对资源所执行的操作来表征该资源,而忽略了它们的内部结构和实现细节。</p><p>利用共享数据结构抽象地表示系统中的共享资源,而把对该共享数据结构实施的操作定义为一组过程。</p><p>代表共享资源的数据结构,以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序,共同构成了一个操作系统的资源管理模块,我们称之为管程。</p><p>一个管程定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作,这组操作能同步进程和改变管程中的数据局部于管程的数据结构,只能被局部于管程的过程所访问,任何管程之外的过程都不能访问它;反之,局部于管程的过程也只能访问管程内的数据结构。由此可见,管程相当于围墙,它把共享变量和对它进行操作的若干个过程围了起来,所有进程要访问临界资源时,都必须经过管程才能进入,而管程每次只允许一个进程进入管程,从而实现了进程的互斥。 [5] </p><p>当下推出的<a href="https://baike.baidu.com/item/%E9%80%9A%E7%94%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">通用操作系统</a>都引入了<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B?fromModule=lemma_inlink">线程</a>，以便进一步提高系统的并发性，并把它视为<a href="https://baike.baidu.com/item/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">现代操作系统</a>的一个重要指标。</p><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p>进程控制是进程管理中最基本的功能。它用于创建一个新进程，终止一个已完成的进程，或者去终止一个因出现某事件而使其无法运行下去的进程，还可负责进程运行中的状态转换。</p><p><strong>创建进程</strong></p><p><strong>1.引起创建进程的事件</strong></p><p>在<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F?fromModule=lemma_inlink">多道程序</a>环境中，只有（作为）进程（时）才能在系统中运行。因此，为使程序能运行，就必须为它创建进程。导致一个进程去创建另一个进程的典型事件，可以有以下四类：</p><p>1） 用户登录</p><p>在<a href="https://baike.baidu.com/item/%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">分时系统</a>中，用户在终端键入登录命令后，如果是合法用户，系统将为该终端建立一个进程，并把它插入到就绪<a href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97?fromModule=lemma_inlink">队列</a>中。</p><p>2）<a href="https://baike.baidu.com/item/%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6?fromModule=lemma_inlink">作业调度</a></p><p>在<a href="https://baike.baidu.com/item/%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">批处理系统</a>中，当作业调度程序按照一定的算法调度到某作业时，便将该作业装入到<a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98?fromModule=lemma_inlink">内存</a>，为它分配必要的资源，并立即为它创建进程，再插入到就绪<a href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97?fromModule=lemma_inlink">队列</a>中。</p><p>3） 提供服务</p><p>当运行中的<a href="https://baike.baidu.com/item/%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F?fromModule=lemma_inlink">用户程序</a>提出某种请求后，系统将专门创建一个进程来提供用户所需要的服务，例如，用户程序要求进行文件打印，<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">操作系统</a>将为它创建一个打印进程，这样，不仅可以使打印进程与该用户进程并发执行，而且还便于计算出为完成打印任务所花费的时间。</p><p>4） 应用请求</p><p>在上述三种<a href="https://baike.baidu.com/item/%E6%83%85%E5%86%B5?fromModule=lemma_inlink">情况</a>中，都是由系统<a href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8?fromModule=lemma_inlink">内核</a>为它创建一个新进程，而这一类事件则是基于应用进程的需求，由它创建一个新的进程，以便使新进程以并发的运行方式完成特定任务。</p><p><strong>2.进程的创建过程</strong></p><p>一旦<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">操作系统</a>发现了要求创建新进程的事件后，便调用进程创建<a href="https://baike.baidu.com/item/%E5%8E%9F%E8%AF%AD?fromModule=lemma_inlink">原语</a>create()按下述步骤创建一个新进程。</p><p>1） 申请空白PCB。为新进程申请获得唯一的数字<a href="https://baike.baidu.com/item/%E6%A0%87%E8%AF%86%E7%AC%A6?fromModule=lemma_inlink">标识符</a>，并从PCB集合中索取一个空白PCB。</p><p>2） 为新进程分配资源。为新进程的程序和数据以及<a href="https://baike.baidu.com/item/%E7%94%A8%E6%88%B7%E6%A0%88?fromModule=lemma_inlink">用户栈</a>分配必要的<a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98?fromModule=lemma_inlink">内存</a>空间。显然，此时<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">操作系统</a>必须知道新进程所需要的<a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98?fromModule=lemma_inlink">内存</a>大小。</p><p>3） 初始化<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97?fromModule=lemma_inlink">进程控制块</a>。PCB的初始化包括：</p><p>①初始化标识信息，将系统分配的标识符和<a href="https://baike.baidu.com/item/%E7%88%B6%E8%BF%9B%E7%A8%8B?fromModule=lemma_inlink">父进程</a>标识符，填入新的PCB中。</p><p>②初始化<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA?fromModule=lemma_inlink">处理机</a>状态信息，使<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8?fromModule=lemma_inlink">程序计数器</a>指向程序的入口地址，使栈<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88?fromModule=lemma_inlink">指针</a>指向栈顶。</p><p>③初始化<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA?fromModule=lemma_inlink">处理机</a>控制信息，将进程的状态设置为<a href="https://baike.baidu.com/item/%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81?fromModule=lemma_inlink">就绪状态</a>或静止就绪状态，对于优先级，通常是将它设置为最低优先级，除非用户以显式的方式提出高优先级要求。</p><p>4） 将新进程插入就绪队列，如果进程就绪<a href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97?fromModule=lemma_inlink">队列</a>能够接纳新进程，便将新进程插入到就绪队列中。</p><p><strong>进程终止</strong></p><p><strong>1.引起进程终止的事件</strong></p><p>1）正常结束</p><p>在任何<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">计算机系统</a>中，都应该有一个表示进程已经运行完成的指示。例如，在<a href="https://baike.baidu.com/item/%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">批处理系统</a>中，通常在程序的最后安排一条Hold指令或终止的系统调用。当程序运行到Hold指令时，将产生一个中断，去通知OS本进程已经完成。</p><p>2）异常结束</p><p>在进程运行期间，由于出现某些错误和故障而迫使进程终止。这类异常事件很多，常见的有：越界错误，保护错，非法指令，<a href="https://baike.baidu.com/item/%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4?fromModule=lemma_inlink">特权指令</a>错，运行超时，等待超时，算术运算错，I/O故障。</p><p>3）外界干预</p><p>外界干预并非指在本进程运行中出现了异常事件，而是指进程应外界的请求而终止运行。这些干预有：操作员或<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">操作系统</a>干预，<a href="https://baike.baidu.com/item/%E7%88%B6%E8%BF%9B%E7%A8%8B?fromModule=lemma_inlink">父进程</a>请求，父进程终止。</p><p><strong>2. 进程的终止过程</strong></p><p>如果系统发生了上述要求终止进程的某事件后，OS便调用进程终止<a href="https://baike.baidu.com/item/%E5%8E%9F%E8%AF%AD?fromModule=lemma_inlink">原语</a>，按下述过程去终止指定的进程。</p><p>1）根据被终止进程的<a href="https://baike.baidu.com/item/%E6%A0%87%E8%AF%86%E7%AC%A6?fromModule=lemma_inlink">标识符</a>，从PCB集合中检索出该进程的PCB，从中读出该进程状态。</p><p>2）若被终止进程正处于<a href="https://baike.baidu.com/item/%E6%89%A7%E8%A1%8C%E7%8A%B6%E6%80%81?fromModule=lemma_inlink">执行状态</a>，应立即终止该进程的执行，并置调度标志为真。用于指示该进程被终止后应重新进行调度。</p><p>3）若该进程还有子孙进程，还应将其所有子孙进程予以终止，以防他们成为不可控的进程。</p><p>4）将被终止的进程所拥有的全部资源，或者归还给其父进程，或者归还给系统。</p><p>5）将被终止进程（它的PCB）从所在队列（或链表）中移出，等待其它程序来搜集信息。</p><p><strong>阻塞唤醒</strong></p><p><strong>1.引起进程阻塞和唤醒的事件</strong></p><p>1）请求<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1?fromModule=lemma_inlink">系统服务</a></p><p>当正在执行的进程请求<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">操作系统</a>提供服务时，由于某种原因，操作系统并不立即满足该进程的要求时，该进程只能转变为<a href="https://baike.baidu.com/item/%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81?fromModule=lemma_inlink">阻塞状态</a>来等待，一旦要求得到满足后，进程被唤醒。</p><p>2）启动某种操作</p><p>当进程启动某种操作后，如果该进程必须在该操作完成之后才能继续执行，则必须先使该进程阻塞，以等待该操作完成，该操作完成后，将该进程唤醒。</p><p>3）新数据尚未到达</p><p>对于相互合作的进程，如果其中一个进程需要先获得另一（合作）进程提供的数据才能运行以对数据进行处理，则是要其所需数据尚未到达，该进程只有（等待）阻塞，等到数据到达后，该进程被唤醒。</p><p>4）无新工作可做</p><p>系统往往设置一些具有某特定功能的<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B?fromModule=lemma_inlink">系统进程</a>，每当这种进程完成任务后，便把自己阻塞起来以等待新任务到来，新任务到达后，该进程被唤醒。</p><p><strong>2.进程阻塞过程</strong></p><p>正在执行的进程，当发现上述某事件后，由于无法继续执行，于是进程便通过调用阻塞<a href="https://baike.baidu.com/item/%E5%8E%9F%E8%AF%AD?fromModule=lemma_inlink">原语</a>block()把自己阻塞。可见，进程的阻塞是进程自身的一种主动行为。进入block过程后，由于此时该进程还处于<a href="https://baike.baidu.com/item/%E6%89%A7%E8%A1%8C%E7%8A%B6%E6%80%81?fromModule=lemma_inlink">执行状态</a>，所以应先立即停止执行，把<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97?fromModule=lemma_inlink">进程控制块</a>中的现行状态由执行改为阻塞，并将PCB插入阻塞<a href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97?fromModule=lemma_inlink">队列</a>。如果系统中设置了因不同事件而阻塞的多个阻塞<a href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97?fromModule=lemma_inlink">队列</a>，则应将本进程插入到具有相同事件的阻塞（等待）队列。最后，转调度程序进行重新调度，将<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA?fromModule=lemma_inlink">处理机</a>分配给另一就绪进程，并进行切换，亦即，保留被阻塞进程的处理机状态（在PCB中），再按新进程的PCB中的处理机状态设置CPU环境。</p><p><strong>3. 进程唤醒过程</strong></p><p>当被阻塞的进程所期待的事件出现时，如I/O完成或者其所期待的数据已经到达，则由有关进程（比如，用完并释放了该I/O设备的进程）调用唤醒原语wakeup()，将等待该事件的进程唤醒。唤醒原语执行的过程是：首先把被阻塞的进程从等待该事件的阻塞<a href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97?fromModule=lemma_inlink">队列</a>中移出，将其PCB中的现行状态由阻塞改为就绪，然后再将该PCB插入到就绪队列中。</p><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>进程的调度算法包括：</p><p>实时系统中：<a href="https://baike.baidu.com/item/FIFO/64838?fromModule=lemma_inlink">FIFO</a>(First Input First Output，<a href="https://baike.baidu.com/item/%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA?fromModule=lemma_inlink">先进先出</a>算法)，SJF(Shortest Job First，最短作业优先算法)，SRTF(Shortest Remaining Time First，最短剩余时间优先算法）。</p><p>交互式系统中：RR(Round Robin，<a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC?fromModule=lemma_inlink">时间片轮转</a>算法)，HPF(Highest Priority First，最高优先级算法)，多级队列，最短进程优先，保证调度，彩票调度，公平分享调度。</p><h3 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h3><p>进程是由<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97?fromModule=lemma_inlink">进程控制块</a>、程序段、数据段三部分组成。一个进程可以包含若干<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B?fromModule=lemma_inlink">线程</a>(Thread)，线程可以帮助应用程序同时做几件事(比如一个线程向<a href="https://baike.baidu.com/item/%E7%A3%81%E7%9B%98?fromModule=lemma_inlink">磁盘</a>写入文件，另一个则接收用户的按键操作并及时做出反应，互相不干扰)，在程序被运行后，系统首先要做的就是为该程序进程建立一个默认线程，然后程序可以根据需要自行添加或删除相关的线程。是可并发执行的程序。在一个数据集合上的运行过程，是系统进行资源分配和调度的一个独立单位，也是称活动、路径或任务，它有两方面性质：活动性、<a href="https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91%E6%80%A7?fromModule=lemma_inlink">并发性</a>。进程可以划分为运行、阻塞、就绪三种状态，并随一定条件而相互转化：就绪–运行，运行–阻塞，阻塞–就绪。</p><p>进程为应用程序的运行实例，是应用程序的一次动态执行。看似高深，我们可以简单地理解为：它是<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">操作系统</a>当前运行的<a href="https://baike.baidu.com/item/%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F?fromModule=lemma_inlink">执行程序</a>。在系统当前运行的执行程序里包括：<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E8%AE%A1%E7%AE%97%E6%9C%BA?fromModule=lemma_inlink">系统管理计算机</a>个体和完成各种操作所必需的程序；用户开启、执行的额外程序，当然也包括用户不知道，而自动运行的<a href="https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E7%A8%8B%E5%BA%8F?fromModule=lemma_inlink">非法程序</a>（它们就有可能是<a href="https://baike.baidu.com/item/%E7%97%85%E6%AF%92?fromModule=lemma_inlink">病毒</a>程序）。  </p><blockquote><p>来自百度百科</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/30/hello-world/"/>
      <url>/2023/03/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java复习</title>
      <link href="/2022/11/07/JAVA%E5%A4%8D%E4%B9%A0/"/>
      <url>/2022/11/07/JAVA%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="一-javac-exe-java-exe-javap-exe-javadoc-exe："><a href="#一-javac-exe-java-exe-javap-exe-javadoc-exe：" class="headerlink" title="一.javac.exe  java.exe  javap.exe  javadoc.exe："></a>一.javac.exe  java.exe  javap.exe  javadoc.exe：</h3><ol><li><p>javac.exe:  Java编译器，将 .java 文件编译成 .class 文件，即将源代码文件编译成字节码文件，字节码文件还不是机器能直接运行的文件。 javac.exe 编译后得到的 .class 文件是二进制指令，但不是机器指令，而是 Java 虚拟机可识别的指令。</p></li><li><p>java.exe:  Java解释器，启动 JVM（Java虚拟机），将 .class 文件一行一行地解释成机器指令执行。（由 Java 虚拟机对字节码进行解释和执行） 这就是为什么 Java 程序能跨平台运行的原因。无论是在Windows、Linux、MAC等系统上，只要装有相应版本的 JVM，该JVM 就能把 .class 文件解释成机器指令执行。实现“一次编译，随处运行”。</p></li><li><p>javap是jdk自带的反解析工具。它的作用就是根据class字节码文件，反解析出当前类对应的code区 （字节码指令）、局部变量表、异常表和代码行偏移量映射表、常量池等信息。</p><p>一般常用的是 -v -l -c 三个选项</p><p>javap -l 会输出行号和本地变量表信息</p><p>javap -c 会对当前 class 字节码进行反编译生成汇编代码。</p><p>java -v classxx 除了包含 -c 内容外，还会输出行号，局部变量表信息、常量池灯信息。不包含私有信息。</p><p>java -v -p classxx 最全的，包括所有的。</p></li><li><p>javadoc是Sun公司提供的一个技术，它从程序<a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81/3969?fromModule=lemma_inlink">源代码</a>中抽取类、方法、成员等注释形成一个和源代码配套的API帮助文档。也就是说，只要在编写程序时以一套特定的标签作注释，在程序编写完成后，通过Javadoc就可以同时形成程序的开发文档了。</p><p>javadoc命令是用来生成自己<a href="https://baike.baidu.com/item/API/10154?fromModule=lemma_inlink">API</a>文档的，使用方式：使用命令行在目标文件所在目录输入javadoc +文件名.java。</p></li></ol><h3 id="二-Java的输入输出："><a href="#二-Java的输入输出：" class="headerlink" title="二.Java的输入输出："></a>二.Java的输入输出：</h3><h4 id="输入：Scanner类"><a href="#输入：Scanner类" class="headerlink" title="输入：Scanner类"></a>输入：Scanner类</h4><p>一、Scanner类简介\nScanner类是在jdk1.5版本引入的，它在java的util工具包下，主要用于扫描用户从控制台输入的文本。\n当我们需要通过控制台输入数据时，只需要事先导入java.util包中的Scanner类，然后调用Scanner类，\n我们的程序就能获取我们在控制台所输入的数据了。</p><p>二、如何使用Scanner类</p><p>1.首先导入java.util.Scanner包；</p><p> <code>import java.util.Scanner;</code></p><p>2.创建Scanner类对象</p><p><code>Scanner sc = new Scanner(System.in);</code></p><p>3.创建一个变量来接收输入的数据</p><p>运用上面创建的sc对象调用对应的方法，控制台即可等待用户输入，我们自定义一个变量来接收即可</p><p>我们想要输入的数据类型不同，也需要调用不同的方法，具体应用如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> a1= sc.nextByte();</span><br><span class="line"></span><br><span class="line"><span class="type">short</span> a2= sc.nextShort();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">a3</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">a4</span> <span class="operator">=</span> sc.nextLong();</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="variable">a5</span> <span class="operator">=</span> sc.nextFloat();</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">a6</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">a7</span> <span class="operator">=</span> sc.nextBoolean();</span><br></pre></td></tr></tbody></table></figure><p>4.关闭Scanner类</p><p>//使用完Scanner后，我们一定要记得将它关闭!</p><p>//因为使用Scanner本质上是打开了一个IO流，如果不关闭的话，它将会一直占用系统资源。</p><p><code>sc.close();</code></p><p>//但是注意一旦你关闭后，就算在sc.close()这行代码后你再重新<code>new Scanner(System.in)</code>，那也不能重新再打开一个扫描器了，如下图会发现程序会报错</p><p>//所以大家一定要在用不到扫描器之后再关闭，即把sc.close()代码放到最后。</p><p>三、next()和nextLine()的区别（很重要）\n从上面的讲解，我们会发现当我们想要输入的数据类型是String时，我们有两个方法可以调用：next()和nextLine()。那这两种方法具体有什么区别呢？我们继续往下看：</p><p>next()用法总结：</p><p>\1. 一定要读取到有效字符后才可以结束输入。</p><p>\2. 对输入的有效字符之前所遇到的空白，会自动将其去除。</p><p>\3. 只有输入的有效字符后才将其后面输入的空白作为结束符。</p><p>\4. next()不能得到带有空格的字符串。</p><p>\5. 读取结束后，该方法会将我们的鼠标定位在我们输入数据的那一行。</p><p>nextLine()用法总结：</p><p> 1、以回车符作为结束标识符，获取到的是回车符前输入的所有字符串（包括空格）。</p><p> 2、读取结束后，该方法会将我们的鼠标定位在我们输入数据的那一行的下一行。</p><p>（3）先使用nextLine再使用next()、nextInt()等没问题，但是先使用next()和nextInt()等之后就不可以再紧跟nextLine使用。（这一点很重要！！！）如果数据在同一行以空格隔开，则int类型数据读取成功，String类型数据会多一个字符串，如果数据以回车隔开，在输入int数据后按回车就将输出语句执行，有时还报数据输入出错异常。</p><p>原因：nextInt()方法根据分隔符比如空格，回车符等从输入流中分割出第一部分将其存入已经定义的int类型的数据中，然后将控制台输入的其他字符传递下去，所以按照上述代码程序从控制台得到了“1+enter”，于是n得到了1，回车留给了str，接着输入自己想输入的字符串就会报错。</p><p>解决办法：</p><p>1、不要求输入数据的类型先后时，将nextLine()放在nextInt()之前进行控制台输入</p><p>2、要求输入数据的输入顺序时，在nextInt()后加两个sc.nextLine()，第一个去解决那个多余的字符，第二个用来读取。</p><p>四、hash×××()的简单使用，判断输入的数据是否为xxx类型。</p><h4 id="输出：print，println，printf"><a href="#输出：print，println，printf" class="headerlink" title="输出：print，println，printf`"></a>输出：print，println，printf`</h4><p><code>print()</code>输出完毕后不换行，而<code>println()</code>输出完毕后会换行，因此</p><p><code>println()</code>不输出任何东西时，就输出一个换行符</p><p><code>printf()</code>沿用了C语言的用法</p><h3 id="三-String及StringBuffer："><a href="#三-String及StringBuffer：" class="headerlink" title="三.String及StringBuffer："></a>三.String及StringBuffer：</h3><h5 id="1、String与StringBuffer的区别的"><a href="#1、String与StringBuffer的区别的" class="headerlink" title="1、String与StringBuffer的区别的"></a>1、String与StringBuffer的区别的</h5><p>简单地说，就是一个变量和常量的关系.StringBuffer对象的内容可以修改;<strong>而字符串对象一旦产生后就不可以被修改</strong>，重新赋值其实是两个对象<br>StringBuffer的内部实现方式和<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&amp;spm=1001.2101.3001.7020">字符串</a>不同，StringBuffer的在进行字符串处理时，不生成新的对象，在内存使用上要优于串类。所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入，删除等操作，使用StringBuffer要更加适合一些。</p><p><strong>字符串</strong>：</p><p>在String类中没有用来改变已有字符串中的某个字符的方法，<strong>由于不能改变一个Java 字符串中的某个单独字符，所以在JDK文档中称String类的对象是不可改变的</strong>，然而，不可改变的字符串具有一个很大的优点：编译器可以把字符串设为共享的。 [1]</p><h5 id="2、变量："><a href="#2、变量：" class="headerlink" title="2、变量："></a>2、变量：</h5><p>在程序运行期间，随时可能产生一些临时数据，应用程序会将这些数据 保存在一些内存单元中，每个内存单元都用一个标识符来标识，这些内存单元被称为变量。定义的标识符就是变量名，内存单元中存储的数据就是变量的值。</p><h5 id="3、StringBuffer-和-StringBuilder-的区别"><a href="#3、StringBuffer-和-StringBuilder-的区别" class="headerlink" title="3、StringBuffer 和 StringBuilder 的区别"></a>3、StringBuffer 和 StringBuilder 的区别</h5><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。</p><p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p><p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p><p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p><p>1、String表示字符串类型，属于 引用数据类型，不属于基本数据类型。</p><p>2、在java中随便使用 双引号括起来 的都是String对象。</p><p>3、java中规定，双引号括起来的字符串，是 不可变 的，也就是说"abc"自出生到最终死亡，不可变，不能变成"abcd"，也不能变成"ab"。</p><p>4.字符串常量池</p><p>​     字符串常量池即String Pool 但是jvm中对应的类是StringTable 底层实现为hashtable，hashtable就是一个数组加链表的结构。</p><p>​    下图对应代码 String str1 = “11” 它底层会创建一个String对象实例 然后char会指向oop模型的typeArrayOopDesc（c++类）然后会把这个String封装成一个HashtableEntry它的value就是String的char数组然后把HashtableEntry放入常量池中或者可以理解为底层创建了一个String对象实例 然后又创建了一个HashtableEntry的c++对象 这个HashtableEntry的value会指向String对象实例中char数组然后str1指向这个String对象实例 然后HashtableEntry是放在字符串常量池中 字符串常量池可以理解为是一个list集合</p><p><img src="https://img-blog.csdnimg.cn/52d87e0e7d3c4922b777a875e3a176be.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p-T5oyHMTExMA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>   下面的代码对应String str2 = new String(“11”)这里”11”创建了一个char数组并创建了一个String对象实例 然后我们又new了一个String所以我们new的这个String会指向”11”生成的哪个String对象</p><p><img src="https://img-blog.csdnimg.cn/20998d8064c94782a09f9f7b166cd752.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p-T5oyHMTExMA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>  两个双引号的String 会如果值是一样的会共享</p><p><img src="https://img-blog.csdnimg.cn/52fc4de27c3940e894b65401f57a7e02.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p-T5oyHMTExMA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>   new 两个String也会共享相同的数据</p><p><img src="https://img-blog.csdnimg.cn/cc9b073856e940bdae4b9b6524d77ae4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p-T5oyHMTExMA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="String的常用方法"><a href="#String的常用方法" class="headerlink" title="String的常用方法"></a>String的常用方法</h4><h5 id="一-创建String对象"><a href="#一-创建String对象" class="headerlink" title="一.创建String对象"></a>一.创建String对象</h5><p>1.常用的两种方式</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">"11"</span>;</span><br><span class="line">String s1= <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"11"</span>);</span><br></pre></td></tr></tbody></table></figure><p>2.String类还有两个较常用的构造方法<br>(1) String(char a[])用一个字符数组a创建一个String对象。例如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] a={<span class="string">'J'</span>,<span class="string">'a'</span>,<span class="string">'v'</span>,<span class="string">'a'</span>};</span><br><span class="line">String s=<span class="keyword">new</span> <span class="title class_">String</span>(a);</span><br><span class="line"></span><br><span class="line">上述过程相当于</span><br><span class="line">String s=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"Java"</span>);</span><br></pre></td></tr></tbody></table></figure><p>(2) String(char a[ ] , int startIndex , int count)提取字符数组a中的一部分字符创建一个String对象，参数startIndex和count分别指定在a中提取字符的起始位置和从该位置开始截取的字符个数</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[]={<span class="string">'我'</span>,<span class="string">'们'</span>,<span class="string">'是'</span>,<span class="string">'学'</span>,<span class="string">'生'</span>};</span><br><span class="line">String s=<span class="keyword">new</span> <span class="title class_">String</span>(a,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//s=是学生</span></span><br></pre></td></tr></tbody></table></figure><p>3.创建字符串数组：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String [] str = <span class="keyword">new</span> <span class="title class_">String</span> [<span class="number">20</span>];<span class="comment">//20为字符串数组长度</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h5 id="二-String类的常用方法"><a href="#二-String类的常用方法" class="headerlink" title="二.String类的常用方法"></a>二.String类的常用方法</h5><p>1、length()方法用来获取一个String对象的字符序列的长度</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">"abccc"</span>;</span><br><span class="line"><span class="type">int</span> l=str.length();</span><br></pre></td></tr></tbody></table></figure><p>2、equals(String s)方法比较当前对象的字符序列是否与参数s指定的String对象的字符序列相同</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">"你"</span>;</span><br><span class="line">String str1=<span class="string">"好"</span>;</span><br><span class="line">String str2=<span class="string">"你"</span>;</span><br><span class="line">System.out.println(str.equals(str1));<span class="comment">//false</span></span><br><span class="line">System.out.println(str.equals(str2));<span class="comment">//true</span></span><br></pre></td></tr></tbody></table></figure><p>3、 startsWith() 、 endsWith()判断当前String对象的字符序列前缀或后缀是否是参数指定的String对象s的字符序列</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">"天干物燥，小心火烛"</span>;</span><br><span class="line">String str1=<span class="string">"天气预报，阴转小雨"</span>;</span><br><span class="line">System.out.println(str1.startsWith(<span class="string">"天气"</span>));<span class="comment">//true</span></span><br><span class="line">System.out.println(str.startsWith(<span class="string">"天气"</span>));<span class="comment">//false</span></span><br><span class="line">System.out.println(str.endsWith(<span class="string">"小雨"</span>));<span class="comment">//false</span></span><br><span class="line">System.out.println(str1.endsWith(<span class="string">"小雨"</span>));<span class="comment">//true</span></span><br></pre></td></tr></tbody></table></figure><p>4、compareTo(String s)，按字典序与参数指定的String对象s的字符序列比较大小。如果当前String对象的字符序列与s的相同，该方法返回值0；如果大于s的字符序列，该方法返回正值；如果小于s的字符序列，该方法返回负值</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">"abcde"</span>;</span><br><span class="line">System.out.println(str.compareTo(<span class="string">"boy"</span>));<span class="comment">//-1</span></span><br><span class="line">System.out.println(str.compareTo(<span class="string">"aba"</span>));<span class="comment">//2</span></span><br><span class="line">System.out.println(str.compareTo(<span class="string">"abcde"</span>));<span class="comment">//0</span></span><br></pre></td></tr></tbody></table></figure><p>按字典序比较两个String还可以使用compareToIgnoreCase(String s)方法，该方法对比时不区分大小写</p><p>5、contains(String s)判断当前String对象的字符序列是否包含参数s的字符序列</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">"abcde"</span>;</span><br><span class="line">System.out.println(str.contains(<span class="string">"bcd"</span>));<span class="comment">//true</span></span><br><span class="line">System.out.println(str.contains(<span class="string">"bcde"</span>));<span class="comment">//true</span></span><br><span class="line">System.out.println(str.contains(<span class="string">"bcc"</span>));<span class="comment">//false</span></span><br></pre></td></tr></tbody></table></figure><p>6、indexOf(String s)和lastIndexOf(String s)从当前String对象的字符序列的0索引位置开始检索首次或最后一次出现s的字符序列的位置，并返回该位置，如果没有检索到，返回值为-1；indexOf(String s,int startpoint)方法是一个重载方法，参数startpoint的值用来指定索引的开始位置</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">"I am a good girl"</span>;</span><br><span class="line">System.out.println(str.indexOf(<span class="string">"o"</span>));<span class="comment">//8</span></span><br><span class="line">System.out.println(str.lastIndexOf(<span class="string">"o"</span>));<span class="comment">//9</span></span><br><span class="line">System.out.println(str.indexOf(<span class="string">"good"</span>,<span class="number">2</span>));<span class="comment">//7</span></span><br></pre></td></tr></tbody></table></figure><p>7、substring(int startpoint)复制当前String对象的字符序列中的startpoint位置至最后位置上的字符所得到的字符序列；substring(int start，int end)复制从start位置到end位置的字符序列</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">"abccc"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> str.substring(<span class="number">1</span>); <span class="comment">//返回一个新字符串bccc，内容为指定位置开始到字符串末尾的所有字符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> str.substring(<span class="number">2</span>, <span class="number">4</span>);<span class="comment">//返回一个新字符串，内容为指定位置开始到指定位置结束所有字符</span></span><br></pre></td></tr></tbody></table></figure><h5 id="三-字符串的并置："><a href="#三-字符串的并置：" class="headerlink" title="三.字符串的并置："></a>三.字符串的并置：</h5><p>String对象可以用’+’进行并置运算，即首尾相接得到一个新的String对象。例如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">"你"</span>;</span><br><span class="line">String str1=<span class="string">"好"</span>;</span><br><span class="line">String s;</span><br><span class="line">s=str+str1;</span><br></pre></td></tr></tbody></table></figure><h5 id="四-字符串拆分与拼接"><a href="#四-字符串拆分与拼接" class="headerlink" title="四.字符串拆分与拼接"></a>四.字符串拆分与拼接</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//String str="nowcoder. a am I";</span></span><br><span class="line"></span><br><span class="line">String[] str1 =str.split(<span class="string">" "</span>);<span class="comment">//以空格拆分</span></span><br><span class="line"></span><br><span class="line">StringBuilder str2= <span class="keyword">new</span>                   </span><br><span class="line"><span class="title class_">StringBuilder</span>();<span class="comment">//StringBuilder是一个字符拼接的工具类</span></span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=str1.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">    str2.append(str1[i]+<span class="string">' '</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> str2.toString().trim();<span class="comment">//toString()转换为字符串，  trim()去掉两边的空格</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h5 id="五-字符串与基本数据的相互转化"><a href="#五-字符串与基本数据的相互转化" class="headerlink" title="五.字符串与基本数据的相互转化"></a>五.字符串与基本数据的相互转化</h5><p>1、Integer.parseInt(String s)将由“数字”字符组成的字符序列转化为int型数据</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line">String str=<span class="string">"888"</span>;</span><br><span class="line">x=Integer.parseInt(str);</span><br></pre></td></tr></tbody></table></figure><p>2、String.valueOf()将数值转化为String对象</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str=String.valueOf(<span class="number">1234.567</span>);</span><br></pre></td></tr></tbody></table></figure><h5 id="六-对象的字符串表示"><a href="#六-对象的字符串表示" class="headerlink" title="六.对象的字符串表示"></a>六.对象的字符串表示</h5><p>1、toString()获得该对象的字符串表示</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s="adsd";</span><br><span class="line"> String str=s.toString();</span><br></pre></td></tr></tbody></table></figure><h5 id="七-字符串与字符数组与字节数组"><a href="#七-字符串与字符数组与字节数组" class="headerlink" title="七.字符串与字符数组与字节数组"></a>七.字符串与字符数组与字节数组</h5><p>1、toCharArray()将字符串转成一个字符数组</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = "abccc";</span><br><span class="line">char[] chs = str.toCharArray();</span><br></pre></td></tr></tbody></table></figure><p>2、getChars(int start,int end,char c[],int offset)将当前String对象的一部分字复制到参数c指定的数组中，将字符序列中从start到end-1位置上的字符复制到c中，并从数组c的offset处开始存放这些字符</p><p>注意：必须保证数组c能容纳下要被复制的字符</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s="我爱学习lalala";</span><br><span class="line">char[]a=new char[4];</span><br><span class="line">s.getChars(0,4,a,0);</span><br><span class="line">System.out.println(a);//我爱学习</span><br></pre></td></tr></tbody></table></figure><p>3、String(byte[],int offset,int length)用指定的字节数组的一部分，即从数组起始位置offset开始取length个字节，构造一个String对象</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">byte d[] = "abcdefgh".getBytes();</span><br><span class="line">System.out.println(d.length);//8</span><br><span class="line">String s=new String(d,6,2);</span><br><span class="line">System.out.println(s);//gh</span><br><span class="line">s=new String(d,0,6);</span><br><span class="line">System.out.println(s);//abcdef</span><br></pre></td></tr></tbody></table></figure><p>4、Integer.toBinaryString()将字符串转成一个二进制</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str=Integer.toBinaryString(n);//数字转换为二进制字符串</span><br></pre></td></tr></tbody></table></figure><h4 id="StringBuffer的常用方法"><a href="#StringBuffer的常用方法" class="headerlink" title="StringBuffer的常用方法"></a>StringBuffer的常用方法</h4><p>1、append(String s)将String对象s的字符序列追加到当前StringBuffer对象的字符序列中，并返回当前StringBuffer对象的引用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer str=new StringBuffer();</span><br><span class="line">str.append("I am a good girl");</span><br><span class="line">System.out.println(str);//I am a good girl</span><br></pre></td></tr></tbody></table></figure><p>2、StringBuffer append(int n)将int型数据n转化为String对象</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer str=new StringBuffer();</span><br><span class="line">str.append("888");</span><br><span class="line">System.out.println(str);//888</span><br></pre></td></tr></tbody></table></figure><p>3、char charAt(int n)得到StringBuffer对象的字符序列位置n上的字符</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer str=new StringBuffer("I am a good girl");</span><br><span class="line">System.out.println(str.charAt(3));//m</span><br></pre></td></tr></tbody></table></figure><p>4、setCharAt(int n,char ch)将当前StringBuffer对象的字符序列位置n处的字符用参数ch指定的字符替换</p><p> StringBuffer str=new StringBuffer(“I am a good boy”);<br> str.setCharAt(0,’H’);<br> System.out.println(str);//H am a good boy</p><p>5、insert(int index,String str)将参数str指定的字符序列插入到参数index指定的位置并返回当前对象的引用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer str=new StringBuffer("I  a good girl");</span><br><span class="line"> str.setCharAt(2,'a');</span><br><span class="line"> str.setCharAt(3,'m');</span><br><span class="line"> System.out.println(str);//I am good girl</span><br></pre></td></tr></tbody></table></figure><p>6、reverse()将该对象实体中的字符序列翻转，并返回当前对象的引用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer str=new StringBuffer("Hello");</span><br><span class="line">System.out.println(str.reverse());//olleH</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>7、delete(int startIndex,int endIndex)删除一个子字符序列，从startIndex位置到endIndex-1位置处的字符序列被删除</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer str=new StringBuffer("Habcello");</span><br><span class="line">str.delete(1,4);</span><br><span class="line">System.out.println(str);//Hello</span><br></pre></td></tr></tbody></table></figure><p>8、replace(int startIndex，int endIndex,String str)将当前StringBuffer对象的字符序列的一个子字符序列用参数str指定的字符序列替换，从startIndex位置到endIndex-1位置处的字符序列被替换</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer str=new StringBuffer("Hello");</span><br><span class="line">str.replace(1,5,"ahah");</span><br><span class="line">System.out.println(str);//Hahah</span><br></pre></td></tr></tbody></table></figure><p>9.replace() 起到了一个字符串替换的作用（修改对象中的元素）</p><p>实现代码</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = "We are happy."</span><br><span class="line"> a = a.replace(" ","%20");</span><br><span class="line"> System.out.println(a);</span><br></pre></td></tr></tbody></table></figure><p>输出结果：<br>We%20are%20happy.<br>空格被替换成了%20</p><p>10.copyOfRange(original,int from,int to)该方法返回一个长度为to-from的数组，其中from~min(original.length,to)之间的元素（不包括min(original.length,to)）是从数组original复制的元素，剩下的值为0。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] str = <span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>};</span><br><span class="line"><span class="type">int</span>[] str1 = Arrays.copyOfRange(str, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str1.length; i++)</span><br><span class="line">    System.out.print(str1[i]+<span class="string">" "</span>);<span class="comment">//Output  1 2 3 4</span></span><br><span class="line">String str=<span class="string">"I am a girl"</span>;</span><br><span class="line"><span class="type">char</span>[] str2=str.toCharArray();</span><br><span class="line"><span class="type">char</span>[] str1 = Arrays.copyOfRange(str2, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str1.length; i++)</span><br><span class="line">    System.out.print(str1[i]);<span class="comment">//Output  I am</span></span><br></pre></td></tr></tbody></table></figure><p>原文链接：<a href="https://blog.csdn.net/Piink/article/details/123289914">https://blog.csdn.net/Piink/article/details/123289914</a></p><p>一、数据类型和‘==’<br>\1. 基本数据类型(也称原始数据类型): byte,short,char,int,long,float,double,boolean等等<br>  基本数据类型，用“==”比较的时候，比较的就是他们的值<br>　比如 int a = 10; int b = 10; a == b?  10等于10，那么返回的是True</p><p>2.引用数据类型: String,类，接口，数组，注解等等<br>  引用数据，用“==”比较的时候,比较的是他们的在内存存放的地址值</p><p>二、equals<br>\1. equals是在Object类（为所有类的父类）中定义了的一种非静态的方法，需要用 对象名.equals(参数) 进行使用，所以equals只能比较引用数据类型，因为引用数据类型才能像类一样实例化出对象来使用方法，而基本数据类型不能进行实例化对象<br>\2. equals方法在Object类中的源码为： public boolean equals(Object obj) { //this - s1 //obj - s2 return (this == obj);}<br>  由此可知equals默认情况下也是比较对象的内存地址值，所以实际情况下意义不大，一般我们的会对equals进行重写，使它一般用来比较对象的属性值是否相同<br>\3. 对于引用数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是内存中的存放位置的地址值，跟双等号（==）的结果相同；如果被重写，按照重写的要求来。</p><p>三、“==”和equals的区别<br>\1. 最本质的区别：== 是像 +、-、* 这类的运算符，可直接使用，而equals是一种非静态的方法，需要对象调用<br>\2. == 既可以比较基本数据类型，也可以比较引用数据类型，比较基本数据类型比较的是值，比较引用数据类型比较的是地址值<br>\3. equals只能比较引用数据类型，且Object类的equals默认情况下是比较的是地址值，无意义，子类一般会重写，改为比较：属性值</p><h3 id="四-ascii码：A，a，0"><a href="#四-ascii码：A，a，0" class="headerlink" title="四.ascii码：A，a，0,"></a>四.ascii码：A，a，0,</h3><p>A: 65;</p><p>a: 97;</p><p>0:48</p><h3 id="五-Java中的length"><a href="#五-Java中的length" class="headerlink" title="五.Java中的length"></a>五.Java中的length</h3><p><strong>一.</strong></p><ol><li><p>Java中的length属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了length这个属性.</p></li><li><p>java中的length()方法是针对字符串String说的,如果想看这个字符串的长度则用到length()这个方法.</p></li></ol><p>例子：</p><p>1 .所对应的用法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] list={<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>};</span><br><span class="line">System.out.println(list.length);</span><br></pre></td></tr></tbody></table></figure><p>2 .所对应的用法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a=<span class="string">"apple"</span>;</span><br><span class="line">System.out.println(a.length());</span><br></pre></td></tr></tbody></table></figure><p><strong>二.</strong></p><p>a.length 是求数组的长度。<br>a[i].length()应该是求二维数组第i行的长度。</p><h3 id="六-final和static"><a href="#六-final和static" class="headerlink" title="六. final和static"></a>六. final和static</h3><h5 id="static"><a href="#static" class="headerlink" title="static"></a>static</h5><p>static是静态的意思，也是全局的意思。static定义的东西，属于全局，与类相关，不与具体实例相关，是类实例之间共享的。</p><ol><li><p>被static修饰的变量属于类变量，可以通过类名.变量名直接引用，而不需要new出一个对象来</p></li><li><p>被static修饰的方法属于类方法，可以通过类名.方法名直接引用，而不需要new出一个对象来</p></li></ol><h6 id="static与非static的区别："><a href="#static与非static的区别：" class="headerlink" title="static与非static的区别："></a>static与非static的区别：</h6><p>在内存中存放的位置不同：所有static修饰的属性和方法都放在内存的方法区（内存的方法区相当于常驻内存，如果一个方法或者变量声明为static，可以节约内存，不必要为每个对象实例化的时候分配内存）里，而非静态的都堆放在堆内存中</p><p>生命周期不同：静态在类消失后被销毁，非静态在对象销毁后销毁。</p><h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><p>final关键字有三个东西可以修饰，修饰非抽象类，修饰非抽象方法，修饰引用。</p><h6 id="在类的声明中使用final"><a href="#在类的声明中使用final" class="headerlink" title="在类的声明中使用final:"></a>在类的声明中使用final:</h6><p>使用了final的类不能再派生子类，就是不可以被继承，简称为断子绝孙类。类中的所有方法都不能被重写。有一些java的面试题问，String可不可以被继承，答案是不可以。因为java.lang.String是一个final类。这可以保证String对象方法的调用确实运行的是String类的方法，而不是经其子类重写后的方法。</p><h6 id="在方法的声明中使用final"><a href="#在方法的声明中使用final" class="headerlink" title="在方法的声明中使用final:"></a>在方法的声明中使用final:</h6><p>被定义为final的方法不能被重写，这个方法成为最终方法，但是该方法仍然可以被继承。如果定义类为final，是所有的方法都不能被重写。而我们只需要类中的几个方法不可以被重写，就在方法前面加上final，而且被定义为final的方法执行效率高。final不能修饰构造方法。</p><h6 id="在修饰引用中使用final："><a href="#在修饰引用中使用final：" class="headerlink" title="在修饰引用中使用final："></a>在修饰引用中使用final：</h6><p><strong>如果引用为基本数据类型，这样变量就是常量了，在程序中这样的变量不可以被修改</strong>，修改编译器会报错，而且执行效率比普通的变量要高。final的变量如果没有赋予初值的话，其他方法就必须给他赋值，但只能赋值一次。</p><p>如果引用为引用数据类型，比如对象，数组，则该对象、数组本身可以修改，但是指向该对象或数组的地址的引用不能修改。</p><p>如果引用的是类的成员变量，则必须当场赋值，否则编译会报错。</p><p>static和final一起用：final与static final的区别是：final在一个对象类唯一，static final在多个对象中都唯一；一个既是static又是final的域只占据一段不能改变的存储空间，只有一份。<br>原文链接：<a href="https://blog.csdn.net/dlz_yhn/article/details/124734450">https://blog.csdn.net/dlz_yhn/article/details/124734450</a></p><h3 id="七-Swing界面问题"><a href="#七-Swing界面问题" class="headerlink" title="七.Swing界面问题"></a>七.Swing界面问题</h3><h5 id="Java-Swing布局管理器"><a href="#Java-Swing布局管理器" class="headerlink" title="Java Swing布局管理器"></a>Java Swing布局管理器</h5><p>在使用 <a href="http://c.biancheng.net/swing/">Swing</a> 向容器添加组件时，需要考虑组件的位置和大小。如果不使用布局管理器，则需要先在纸上画好各个组件的位置并计算组件间的距离，再向容器中添加。这样虽然能够灵活控制组件的位置，实现却非常麻烦。</p><p>为了加快开发速度，<a href="http://c.biancheng.net/java/">Java</a> 提供了一些布局管理器，它们可以将组件进行统一管理，这样开发人员就不需要考虑组件是否会重叠等问题。本节介绍 Swing 提供的 6 种布局类型，所有布局都实现 LayoutManager 接口。</p><h5 id="边框布局管理器"><a href="#边框布局管理器" class="headerlink" title="边框布局管理器"></a>边框布局管理器</h5><p>BorderLayout（边框布局管理器）是 Window、JFrame 和 JDialog 的默认布局管理器。边框布局管理器将窗口分为 5 个区域：North、South、East、West 和 Center。其中，North 表示北，将占据面板的上方；Soufe 表示南，将占据面板的下方；East表示东，将占据面板的右侧；West 表示西，将占据面板的左侧；中间区域 Center 是在东、南、西、北都填满后剩下的区域，如图 1 所示。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e55fb27de618f9da4f0c1446dfe1f1da.gif" alt="框布局管理器区域划分示意图"></p><p>图1 边框布局管理器区域划分示意图</p><p>提示：边框布局管理器并不要求所有区域都必须有组件，如果四周的区域（North、South、East 和 West 区域）没有组件，则由 Center 区域去补充。如果单个区域中添加的不只一个组件，那么后来添加的组件将覆盖原来的组件，所以，区域中只显示最后添加的一个组件。</p><p>BorderLayout 布局管理器的构造方法如下所示。</p><ul><li>BorderLayout()：创建一个 Border 布局，组件之间没有间隙。</li><li>BorderLayout(int hgap,int vgap)：创建一个 Border 布局，其中 hgap 表示组件之间的横向间隔；vgap 表示组件之间的纵向间隔，单位是像素。</li></ul><p>例 1</p><p>使用 BorderLayout 将窗口分割为 5 个区域，并在每个区域添加一个标签按钮。实现代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch17;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JPanel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BorderLayoutDemo</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JFrame frame=<span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">"Java第三个GUI程序"</span>);    <span class="comment">//创建Frame窗口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.setSize(<span class="number">400</span>,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.setLayout(<span class="keyword">new</span> <span class="title class_">BorderLayout</span>());    <span class="comment">//为Frame窗口设置布局为BorderLayout</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JButton button1=<span class="keyword">new</span> <span class="title class_">JButton</span> (<span class="string">"上"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JButton button2=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"左"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JButton button3=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"中"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JButton button4=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"右"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JButton button5=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"下"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.add(button1,BorderLayout.NORTH);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.add(button2,BorderLayout.WEST);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.add(button3,BorderLayout.CENTER);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.add(button4,BorderLayout.EAST);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.add(button5,BorderLayout.SOUTH);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.setBounds(<span class="number">300</span>,<span class="number">200</span>,<span class="number">600</span>,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在该程序中分别指定了 BorderLayout 布局的东、南、西、北、中间区域中要填充的按钮。该程序的运行结果如图 2 所示。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3fb6bf32d224a68cff6e8875ee691ba3.gif" alt="填充5个区域的效果"></p><p>图2 填充5个区域的效果</p><p>如果未指定布局管理器的 NORTH 区域，即将“frame.add(button1,BorderLayout.NORTH);”注释掉，则 WEST、CENTER 和 EAST 3 个区域将会填充 NORTH 区域，如图 3 所示。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/de0715846f348c8dbc784274ad34e72d.gif" alt="缺少 NORTH 区域"></p><p>图3 缺少NORTH区域</p><p>同理，如果未指定布局管理器的 WEST 区域，即将“frame.add(button2,BorderLayout.WEST);”注释掉，则 CENTER 区域将会自动拉伸填充 WEST 区域，如图 4 所示。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/531f6e043c99dd8d61b92e199d6421a1.gif" alt="缺少 WEST 区域"></p><p>图4 缺少WEST区域</p><h5 id="流式布局管理器"><a href="#流式布局管理器" class="headerlink" title="流式布局管理器"></a>流式布局管理器</h5><p>FlowLayout（流式布局管理器）是 JPanel 和 JApplet 的默认布局管理器。FlowLayout 会将组件按照从上到下、从左到右的放置规律逐行进行定位。与其他布局管理器不同的是，FlowLayout 布局管理器不限制它所管理组件的大小，而是允许它们有自己的最佳大小。</p><p>FlowLayout 布局管理器的构造方法如下。</p><ul><li>FlowLayout()：创建一个布局管理器，使用默认的居中对齐方式和默认 5 像素的水平和垂直间隔。</li><li>FlowLayout(int align)：创建一个布局管理器，使用默认 5 像素的水平和垂直间隔。其中，align 表示组件的对齐方式，对齐的值必须是 FlowLayoutLEFT、FlowLayout.RIGHT 和 FlowLayout.CENTER，指定组件在这一行的位置是居左对齐、居右对齐或居中对齐。</li><li>FlowLayout(int align, int hgap,int vgap)：创建一个布局管理器，其中 align 表示组件的对齐方式；hgap 表示组件之间的横向间隔；vgap 表示组件之间的纵向间隔，单位是像素。</li></ul><p>例 2</p><p>创建一个窗口，设置标题为“Java第四个GUI程序”。使用 FlowLayout 类对窗口进行布局，向容器内添加 9 个按钮，并设置横向和纵向的间隔都为 20 像素。具体实现代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch17;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JPanel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlowLayoutDemo</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JFrame jFrame=<span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">"Java第四个GUI程序"</span>);    <span class="comment">//创建Frame窗口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JPanel jPanel=<span class="keyword">new</span> <span class="title class_">JPanel</span>();    <span class="comment">//创建面板</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JButton btn1=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"1"</span>);    <span class="comment">//创建按钮</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JButton btn2=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"2"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JButton btn3=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"3"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JButton btn4=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"4"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JButton btn5=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"5"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JButton btn6=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"6"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JButton btn7=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"7"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JButton btn8=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"8"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JButton btn9=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"9"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        jPanel.add(btn1);    <span class="comment">//面板中添加按钮</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        jPanel.add(btn2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        jPanel.add(btn3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        jPanel.add(btn4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        jPanel.add(btn5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        jPanel.add(btn6);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        jPanel.add(btn7);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        jPanel.add(btn8);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        jPanel.add(btn9);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//向JPanel添加FlowLayout布局管理器，将组件间的横向和纵向间隙都设置为20像素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        jPanel.setLayout(<span class="keyword">new</span> <span class="title class_">FlowLayout</span>(FlowLayout.LEADING,<span class="number">20</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        jPanel.setBackground(Color.gray);    <span class="comment">//设置背景色</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        jFrame.add(jPanel);    <span class="comment">//添加面板到容器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        jFrame.setBounds(<span class="number">300</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">150</span>);    <span class="comment">//设置容器的大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        jFrame.setVisible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述程序向 JPanel 面板中添加了 9 个按钮，并使用 HowLayout 布局管理器使 9 个按钮间的横向和纵向间隙都为 20 像素。此时这些按钮将在容器上按照从上到下、从左到右的顺序排列，如果一行剩余空间不足容纳组件将会换行显示，最终运行结果如图 5 所示。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/dde39f0823316df8de1fef4f98d4cffc.gif" alt="FlowLayout布局按钮结果"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/fbb572a3f35155d552af1cdabf2e7a66.gif" alt="FlowLayout布局按钮结果"></p><p>图5 FlowLayout布局按钮结果</p><h5 id="卡片布局管理器"><a href="#卡片布局管理器" class="headerlink" title="卡片布局管理器"></a>卡片布局管理器</h5><p>CardLayout（卡片布局管理器）能够帮助用户实现多个成员共享同一个显示空间，并且一次只显示一个容器组件的内容。</p><p>CardLayout 布局管理器将容器分成许多层，每层的显示空间占据整个容器的大小，但是每层只允许放置一个组件。CardLayout 的构造方法如下。</p><ul><li>CardLayout()：构造一个新布局，默认间隔为 0。</li><li>CardLayout(int hgap, int vgap)：创建布局管理器，并指定组件间的水平间隔（hgap）和垂直间隔（vgap）。</li></ul><p>例 3</p><p>使用 CardLayout 类对容器内的两个面板进行布局。其中第一个面板上包括三个按钮，第二个面板上包括三个文本框。最后调用 CardLayout 类的 show() 方法显示指定面板的内容，代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch17;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JPanel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JTextField;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CardLayoutDemo</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">{   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JFrame frame=<span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">"Java第五个程序"</span>);    <span class="comment">//创建Frame窗口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JPanel p1=<span class="keyword">new</span> <span class="title class_">JPanel</span>();    <span class="comment">//面板1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JPanel p2=<span class="keyword">new</span> <span class="title class_">JPanel</span>();    <span class="comment">//面板2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JPanel cards=<span class="keyword">new</span> <span class="title class_">JPanel</span>(<span class="keyword">new</span> <span class="title class_">CardLayout</span>());    <span class="comment">//卡片式布局的面板</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        p1.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"登录按钮"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        p1.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"注册按钮"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        p1.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"找回密码按钮"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        p2.add(<span class="keyword">new</span> <span class="title class_">JTextField</span>(<span class="string">"用户名文本框"</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        p2.add(<span class="keyword">new</span> <span class="title class_">JTextField</span>(<span class="string">"密码文本框"</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        p2.add(<span class="keyword">new</span> <span class="title class_">JTextField</span>(<span class="string">"验证码文本框"</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        cards.add(p1,<span class="string">"card1"</span>);    <span class="comment">//向卡片式布局面板中添加面板1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        cards.add(p2,<span class="string">"card2"</span>);    <span class="comment">//向卡片式布局面板中添加面板2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        CardLayout cl=(CardLayout)(cards.getLayout());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        cl.show(cards,<span class="string">"card1"</span>);    <span class="comment">//调用show()方法显示面板2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.add(cards);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.setBounds(<span class="number">300</span>,<span class="number">200</span>,<span class="number">400</span>,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码创建了一个卡片式布局的面板 cards，该面板包含两个大小相同的子面板 p1 和 p2。需要注意的是，在将 p1 和 p2 添加到 cards 面板中时使用了含有两个参数的 add() 方法，该方法的第二个参数用来标识子面板。当需要显示某一个面板时，只需要调用卡片式布局管理器的 show() 方法，并在参数中指定子面板所对应的字符串即可，这里显示的是 p1 面板，运行效果如图 6 所示。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2eb6542f217358a9b79714a2fd417564.gif" alt="显示 p1 面板"></p><p>图6 显示p1面板  </p><p>如果将“cl.show(cards,”card1”)”语句中的 card1 换成 card2，将显示 p2 面板的内容，此时运行结果如图 7 所示。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/83c1bbf9f9dfffad8c36f69345bb9cda.gif" alt="显示 p2 面板"></p><p>图7 显示p2面板</p><h5 id="网格布局管理器"><a href="#网格布局管理器" class="headerlink" title="网格布局管理器"></a>网格布局管理器</h5><p>GridLayout（网格布局管理器）为组件的放置位置提供了更大的灵活性。它将区域分割成行数（rows）和列数（columns）的网格状布局，组件按照由左至右、由上而下的次序排列填充到各个单元格中。</p><p>GridLayout 的构造方法如下。</p><ul><li>GridLayout(int rows,int cols)：创建一个指定行（rows）和列（cols）的网格布局。布局中所有组件的大小一样，组件之间没有间隔。</li><li>GridLayout(int rows,int cols,int hgap,int vgap)：创建一个指定行（rows）和列（cols）的网格布局，并且可以指定组件之间横向（hgap）和纵向（vgap）的间隔，单位是像素。</li></ul><p>提示：GridLayout 布局管理器总是忽略组件的最佳大小，而是根据提供的行和列进行平分。该布局管理的所有单元格的宽度和高度都是一样的。</p><p>例 4</p><p>使用 GridLayout 类的网格布局设计一个简单计算器。代码的实现如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch17;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JPanel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JTextField;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GridLayoutDemo</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JFrame frame=<span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">"GridLayou布局计算器"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JPanel panel=<span class="keyword">new</span> <span class="title class_">JPanel</span>();    <span class="comment">//创建面板</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定面板的布局为GridLayout，4行4列，间隙为5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        panel.setLayout(<span class="keyword">new</span> <span class="title class_">GridLayout</span>(<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"7"</span>));    <span class="comment">//添加按钮</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"8"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"9"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"/"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"4"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"5"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"6"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"*"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"1"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"2"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"3"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"-"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"0"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"."</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"="</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"+"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.add(panel);    <span class="comment">//添加面板到容器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.setBounds(<span class="number">300</span>,<span class="number">200</span>,<span class="number">200</span>,<span class="number">150</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述程序设置面板为 4 行 4 列、间隙都为 5 像素的网格布局，在该面板上包含 16 个按钮，其横向和纵向的间隙都为 5。该程序的运行结果如图 8 所示。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9325844c8a641a144a02ffb34fcbe3be.gif" alt="计算器"></p><p>图8 计算器</p><h5 id="网格包布局管理器"><a href="#网格包布局管理器" class="headerlink" title="网格包布局管理器"></a>网格包布局管理器</h5><p>GridBagLayout（网格包布局管理器）是在网格基础上提供复杂的布局，是最灵活、 最复杂的布局管理器。GridBagLayout 不需要组件的尺寸一致，允许组件扩展到多行多列。每个 GridBagLayout 对象都维护了一组动态的矩形网格单元，每个组件占一个或多个单元，所占有的网格单元称为组件的显示区域。</p><p>GridBagLayout 所管理的每个组件都与一个 GridBagConstraints 约束类的对象相关。这个约束类对象指定了组件的显示区域在网格中的位置，以及在其显示区域中应该如何摆放组件。除了组件的约束对象，GridBagLayout 还要考虑每个组件的最小和首选尺寸，以确定组件的大小。</p><p>为了有效地利用网格包布局管理器，在向容器中添加组件时，必须定制某些组件的相关约束对象。GridBagConstraints 对象的定制是通过下列变量实现的。</p><p>\1. gridx 和 gridy</p><p>用来指定组件左上角在网格中的行和列。容器中最左边列的 gridx 为 0，最上边行的 gridy 为 0。这两个变量的默认值是 GridBagConstraints.RELATIVE，表示对应的组件将放在前一个组件的右边或下面。</p><p>\2. gridwidth 和 gridheight</p><p>用来指定组件显示区域所占的列数和行数，以网格单元而不是像素为单位，默认值为 1。</p><p>\3. fill</p><p>指定组件填充网格的方式，可以是如下值：GridBagConstraints.NONE（默认值）、GridBagConstraints.HORIZONTAL（组件横向充满显示区域，但是不改变组件高度）、GridBagConstraints.VERTICAL（组件纵向充满显示区域，但是不改变组件宽度）以及 GridBagConstraints.BOTH（组件横向、纵向充满其显示区域）。</p><p>\4. ipadx 和 ipady</p><p>指定组件显示区域的内部填充，即在组件最小尺寸之外需要附加的像素数，默认值为 0。</p><p>\5. insets</p><p>指定组件显示区域的外部填充，即组件与其显示区域边缘之间的空间，默认组件没有外部填充。</p><p>\6. anchor</p><p>指定组件在显示区域中的摆放位置。可选值有 GridBagConstraints.CENTER（默认值）、GridBagConstraints.NORTH、GridBagConstraints.<br>NORTHEAST、GridBagConstraints.EAST、GridBagConstraints.SOUTH、GridBagConstraints.SOUTHEAST、GridBagConstraints.WEST、GridBagConstraints.SOUTHWEST 以及 GridBagConstraints.NORTHWEST。</p><p>\7. weightx 和 weighty</p><p>用来指定在容器大小改变时，增加或减少的空间如何在组件间分配，默认值为 0，即所有的组件将聚拢在容器的中心，多余的空间将放在容器边缘与网格单元之间。weightx 和 weighty 的取值一般在 0.0 与 1.0 之间，数值大表明组件所在的行或者列将获得更多的空间。</p><p>例 5</p><p>创建一个窗口，使用 GridBagLayout 进行布局，实现一个简易的手机拨号盘。这里要注意如何控制行内组件的显示方式以及使用 GridBagConstraints.REMAINDER 来控制一行的结束。代码的实现如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch17;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JPanel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JTextField;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GridBagLayoutDemo</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向JFrame中添加JButton按钮</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">makeButton</span><span class="params">(String title,JFrame frame,GridBagLayout gridBagLayout,GridBagConstraints constraints)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    {   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JButton button=<span class="keyword">new</span> <span class="title class_">JButton</span>(title);    <span class="comment">//创建Button对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        gridBagLayout.setConstraints(button,constraints);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.add(button);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JFrame frame=<span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">"拨号盘"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        GridBagLayout gbaglayout=<span class="keyword">new</span> <span class="title class_">GridBagLayout</span>();    <span class="comment">//创建GridBagLayout布局管理器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        GridBagConstraints constraints=<span class="keyword">new</span> <span class="title class_">GridBagConstraints</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.setLayout(gbaglayout);    <span class="comment">//使用GridBagLayout布局管理器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        constraints.fill=GridBagConstraints.BOTH;    <span class="comment">//组件填充显示区域</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        constraints.weightx=<span class="number">0.0</span>;    <span class="comment">//恢复默认值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        constraints.gridwidth = GridBagConstraints.REMAINDER;    <span class="comment">//结束行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JTextField tf=<span class="keyword">new</span> <span class="title class_">JTextField</span>(<span class="string">"13612345678"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        gbaglayout.setConstraints(tf, constraints);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.add(tf);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        constraints.weightx=<span class="number">0.5</span>;    <span class="comment">// 指定组件的分配区域</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        constraints.weighty=<span class="number">0.2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        constraints.gridwidth=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        makeButton(<span class="string">"7"</span>,frame,gbaglayout,constraints);    <span class="comment">//调用方法，添加按钮组件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        makeButton(<span class="string">"8"</span>,frame,gbaglayout,constraints);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        constraints.gridwidth=GridBagConstraints.REMAINDER;    <span class="comment">//结束行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        makeButton(<span class="string">"9"</span>,frame,gbaglayout,constraints);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        constraints.gridwidth=<span class="number">1</span>;    <span class="comment">//重新设置gridwidth的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        makeButton(<span class="string">"4"</span>,frame,gbaglayout,constraints);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        makeButton(<span class="string">"5"</span>,frame,gbaglayout,constraints);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        constraints.gridwidth=GridBagConstraints.REMAINDER;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        makeButton(<span class="string">"6"</span>,frame,gbaglayout,constraints);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        constraints.gridwidth=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        makeButton(<span class="string">"1"</span>,frame,gbaglayout,constraints);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        makeButton(<span class="string">"2"</span>,frame,gbaglayout,constraints);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        constraints.gridwidth=GridBagConstraints.REMAINDER;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        makeButton(<span class="string">"3"</span>,frame,gbaglayout,constraints);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        constraints.gridwidth=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        makeButton(<span class="string">"返回"</span>,frame,gbaglayout,constraints);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        constraints.gridwidth=GridBagConstraints.REMAINDER;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        makeButton(<span class="string">"拨号"</span>,frame,gbaglayout,constraints);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        constraints.gridwidth=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.setBounds(<span class="number">400</span>,<span class="number">400</span>,<span class="number">400</span>,<span class="number">400</span>);    <span class="comment">//设置容器大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上述程序中创建了一个 makeButton() 方法，用来将 JButton 组件添加到 JFrame 窗口中。在 main() 方法中分别创建了 GridBagLayout 对象和 GridBagConstraints 对象，然后设置 JFrame 窗口的布局为 GridBagLayout，并设置了 GridBagConstraints 的一些属性。接着将 JTextField 组件添加至窗口中，并通知布局管理器的 GridBagConstraints 信息。</p><p>在接下来的代码中，调用 makeButton() 方法向 JFrame 窗口填充按钮，并使用 GridBagConstraints. REMAINDER 来控制结束行。当一行结束后，重新设置 GridBagConstraints 对象的 gridwidth 为 1。最后设置 JFrame 窗口为可见状态，程序运行后的拨号盘效果如图 9 所示。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/574988975f46d346954a8aad5934b026.gif" alt="拨号盘运行效果"></p><p>图9 拨号盘运行效果</p><h5 id="盒布局管理器"><a href="#盒布局管理器" class="headerlink" title="盒布局管理器"></a>盒布局管理器</h5><p>BoxLayout（盒布局管理器）通常和 Box 容器联合使用，Box 类有以下两个静态方法。</p><ul><li>createHorizontalBox()：返回一个 Box 对象，它采用水平 BoxLayout，即 BoxLayout 沿着水平方向放置组件，让组件在容器内从左到右排列。</li><li>createVerticalBox()：返回一个 Box 对象，它采用垂直 BoxLayout，即 BoxLayout 沿着垂直方向放置组件，让组件在容器内从上到下进行排列。</li></ul><p>Box 还提供了用于决定组件之间间隔的静态方法，如表 1 所示。</p><table><thead><tr><th align="left">网格包布局</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">static Component createHorizontalGlue()</td><td align="left">创建一个不可见的、可以被水平拉伸和收缩的组件</td></tr><tr><td align="left">static Component createVerticalGlue()</td><td align="left">创建一个不可见的、可以被垂直拉伸和收缩的组件</td></tr><tr><td align="left">static Component createHorizontalStrut(int width)</td><td align="left">创建一个不可见的、固定宽度的组件</td></tr><tr><td align="left">static Component createVerticalStrut(int height)</td><td align="left">创建一个不可见的、固定高度的组件</td></tr><tr><td align="left">static Component createRigidArea(Dimension d)</td><td align="left">创建一个不可见的、总是具有指定大小的组件</td></tr></tbody></table><p>BoxLayout 类只有一个构造方法，如下所示。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BoxLayout(Container c,<span class="type">int</span> axis)</span><br></pre></td></tr></tbody></table></figure><p>其中，参数 Container 是一个容器对象，即该布局管理器在哪个容器中使用；第二个参数为 int 型，用来决定容器上的组件水平（X_AXIS）或垂直（Y_AXIS）放置，可以使用 BoxLayout 类访问这两个属性。</p><p>例 6</p><p>使用 BoxLayout 类对容器内的 4 个按钮进行布局管理，使两个按钮为横向排列，另外两个按钮为纵向排列，代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch17;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.Box;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JPanel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JTextField;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoxLayoutDemo</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span></span><br><span class="line">    {</span><br><span class="line">        JFrame frame=<span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">"Java示例程序"</span>);</span><br><span class="line">        Box b1=Box.createHorizontalBox();    <span class="comment">//创建横向Box容器</span></span><br><span class="line">        Box b2=Box.createVerticalBox();    <span class="comment">//创建纵向Box容器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.add(b1);    <span class="comment">//将外层横向Box添加进窗体</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        b1.add(Box.createVerticalStrut(<span class="number">200</span>));    <span class="comment">//添加高度为200的垂直框架</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        b1.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"西"</span>));    <span class="comment">//添加按钮1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        b1.add(Box.createHorizontalStrut(<span class="number">140</span>));    <span class="comment">//添加长度为140的水平框架 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        b1.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"东"</span>));    <span class="comment">//添加按钮2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        b1.add(Box.createHorizontalGlue());    <span class="comment">//添加水平胶水</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        b1.add(b2);    <span class="comment">//添加嵌套的纵向Box容器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加宽度为100，高度为20的固定区域  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        b2.add(Box.createRigidArea(<span class="keyword">new</span> <span class="title class_">Dimension</span>(<span class="number">100</span>,<span class="number">20</span>))); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        b2.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"北"</span>));    <span class="comment">//添加按钮3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        b2.add(Box.createVerticalGlue());    <span class="comment">//添加垂直组件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        b2.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">"南"</span>));    <span class="comment">//添加按钮4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        b2.add(Box.createVerticalStrut(<span class="number">40</span>));    <span class="comment">//添加长度为40的垂直框架</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置窗口的关闭动作、标题、大小位置以及可见性等  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.setBounds(<span class="number">100</span>,<span class="number">100</span>,<span class="number">400</span>,<span class="number">200</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        frame.setVisible(<span class="literal">true</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在程序中创建了 4 个 JButton 按钮和两个 Box 容器（横向 Box 容器和纵向 Box 容器），并将前两个 JButton 按钮添加到横向 Box 容器中，将后两个 JButton 容器添加到纵向 Box 容器中。程序的运行结果如图 10 所示。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/729ba3e57dbd93f3b41096f50edd9a96.gif" alt="BoxLayout运行结果"></p><p>图10 BoxLayout运行结果</p><p>提示：使用盒式布局可以像使用流式布局一样简单地将组件安排在一个容器内。包含盒式布局的容器可以嵌套使用，最终达到类似于无序网格布局那样的效果，却不像使用无序网格布局那样麻烦。<a href="http://t.csdn.cn/Fy5XO">http://t.csdn.cn/Fy5XO</a></p><h4 id="键盘事件："><a href="#键盘事件：" class="headerlink" title="键盘事件："></a>键盘事件：</h4><p>   键盘事件的事件源一般丐组件相关，当一个组件处于激活状态时，按下、释放或敲击键盘上的某个键时就会发生键盘事件。键盘事件的接口是KeyListener，注册键盘事件监视器的方法是addKeyListener(监视器)。实现KeyListener接口有3个：<br><code>keyPressed(KeyEvent e)：</code>键盘上某个键被按下；<br><code>keyReleased(KeyEvent e)：</code>键盘上某个键被按下，又释放；<br><code>keyTyped(KeyEvent e)：keyPressed</code>和<code>keyReleased</code>两个方法的组合。</p><p>管理键盘事件的类是KeyEvent，该类提供方法：<br>public int getKeyCode(),获得按动的键码getKeyChar()获得字符码，键码表在KeyEvent类中定义，参见附录。</p><p>【例 11-20】小应用程序有一个按钮和一个文本区，按钮作为发生键盘事件的事件源，并对它实施监视。程序运行时，先点击按钮，让按钮激活。以后输入英文字母时，在正文区显示输入的字母。字母显示时，字母之间用空格符分隔，且满10个字母时，换行显示。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.applet.*</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example6_10</span> <span class="keyword">extends</span> <span class="title class_">Applet</span> <span class="keyword">implements</span> <span class="title class_">KeyListener</span>{</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>();</span><br><span class="line">    <span class="type">TextArea</span> <span class="variable">text</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextArea</span>(<span class="number">5</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>{</span><br><span class="line">        button.addKeyListener(<span class="built_in">this</span>);</span><br><span class="line">        add(button);add(text);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyPressed</span><span class="params">(KeyEvent e)</span>{</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> e.getKeyCode();</span><br><span class="line">        <span class="keyword">if</span>(t&gt;=KeyEvent.VK_A&amp;&amp;t&lt;=KeyEvent.VK_Z){</span><br><span class="line">            text.append((<span class="type">char</span>)t+<span class="string">" "</span>);</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count%<span class="number">10</span>==<span class="number">0</span>)</span><br><span class="line">                text.append(<span class="string">"\n"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyTyped</span><span class="params">(KeyEvent e)</span>{}</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyReleased</span><span class="params">(KeyEvent e)</span>{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>原文链接：<a href="https://blog.csdn.net/softn/article/details/51523326">https://blog.csdn.net/softn/article/details/51523326</a></p><p>组合键：</p><p>public void keyPressed(KeyEvent kevt) {</p><p>if(kevt.getKeyChar()==’c’) {</p><p>if(kevt.isAltDown())</p><p>//Code if Alt+c pressed</p><p>if(kevt.isControlDown())</p><p>//Code if Ctrl+c pressed</p><p>if(kevt.isShiftDown())</p><p>//Code if Shift+c pressed</p><p>if(kevt.isAltDown()&amp;&amp;kevt.isControlDown()&amp;&amp;(!kevt.isShiftDown()))</p><p>//Code if Alt+Ctrl+c pressed</p><p>if(kevt.isAltDown()&amp;&amp;kevt.isShiftDown()&amp;&amp;(!kevt.isControlDown()))</p><p>//Code if Alt+Shift+c pressed</p><p>if(!(kevt.isAltDown())&amp;&amp;kevt.isControlDown()&amp;&amp;(kevt.isShiftDown()))</p><p>//Code if Shift+Ctrl+c pressed</p><p>if(kevt.isAltDown()&amp;&amp;kevt.isControlDown()&amp;&amp;kevt.isShiftDown())</p><p>//Code if Alt+Ctrl+Shift+c pressed</p><p>}</p><p>public void keyPressed(KeyEvent key) {</p><p>arr[i]=key.getKeyCode();</p><p>i++;</p><p>if((arr[0]==VK_ALT||arr[1]==VK_ALT||arr[2]==VK_ALT)&amp;&amp; (arr[0]==VK_C||arr[1]==VK_C||arr[2]==VK_C)&amp;&amp;(arr[0]==VK_E||arr[1]==VK_E||arr[2]==VK_E)) {</p><p>//Code you want</p><p>}</p><p>}<br><a href="https://blog.csdn.net/weixin_39603573/article/details/114053148">https://blog.csdn.net/weixin_39603573/article/details/114053148</a></p><h3 id="八-异常"><a href="#八-异常" class="headerlink" title="八.异常"></a>八.异常</h3><h5 id="基础概念以及具体实现"><a href="#基础概念以及具体实现" class="headerlink" title="基础概念以及具体实现"></a>基础概念以及具体实现</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ahut.exception.try_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryCatchDetail</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">/* 1.如果发生异常，则异常后面的代码不会执行，直接进入到catch块。</span></span><br><span class="line"><span class="comment">         * 2.如果·异常没有发生，则顺序执行try块，不会进入到catch块</span></span><br><span class="line"><span class="comment">         * 3.如果希望不管是否发生异常，都执行某段代码(比如关闭连接，释放资源等)则使用finally,finally优先执行，</span></span><br><span class="line"><span class="comment">         * 然后才会执行，try或catch块里的return或throw语句 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">"er"</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">"123"</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(str1);</span><br><span class="line">            System.out.println(<span class="string">"数字"</span> + a);</span><br><span class="line">        } <span class="keyword">catch</span> (NumberFormatException e) {</span><br><span class="line">            System.out.println(<span class="string">"异常信息："</span> + e.getMessage());</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            System.out.println(<span class="string">"finally代码块被执行....."</span>);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"程序继续运行...."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ahut.exception.try_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ahut.exception.NullPointerException_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryCatchDetail02</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">       <span class="comment">/* (4).如果try块可能有多个异常，可以使用多个catch捕获，相应处理,但不能同时捕获两个异常。</span></span><br><span class="line"><span class="comment">        要求子类异常写在前面，父类异常卸载后面*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">            person = <span class="literal">null</span>;</span><br><span class="line">            System.out.println(person.getName());<span class="comment">//NullPointerException</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n1 / n2;<span class="comment">//ArithmeticException</span></span><br><span class="line">        } <span class="keyword">catch</span> (NullPointerException e) {</span><br><span class="line">            System.out.println(<span class="string">"空指针异常:"</span> + e.getMessage());</span><br><span class="line">        } <span class="keyword">catch</span> (ArithmeticException e) {</span><br><span class="line">            System.out.println(<span class="string">"算数异常："</span> + e.getMessage());</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"jack"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ahut.exception;</span><br><span class="line"><span class="comment">/* 异常介绍*/</span></span><br><span class="line">     <span class="comment">/*●基本概念</span></span><br><span class="line"><span class="comment">       Java 语言中，将程序执行中发生的不正常情况称为“异常”。（开发过程中的语法错误和逻辑错误不是异常）</span></span><br><span class="line"><span class="comment">       ●执行过程中所发生的异常事件可分为两大类</span></span><br><span class="line"><span class="comment">       1) Error （错误）: Java 虚拟机无法解决的严重问题。如： JVM 系统内部错误、资源</span></span><br><span class="line"><span class="comment">       耗尽等严重情况。比如： StackOverflowError ［栈溢出］和 OOM ( out of</span></span><br><span class="line"><span class="comment">       memory ), Error 是严重错误，程序会崩溃。</span></span><br><span class="line"><span class="comment">       2) Exception ：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针</span></span><br><span class="line"><span class="comment">       对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等， Exception 分为两大类：运行时异常］和编译时异常［]。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exception01</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//ctrl + alt 代码格式化，即自动对=对齐</span></span><br><span class="line">        <span class="comment">//为了不让程序崩溃，所以设计了异常处理机制</span></span><br><span class="line">        <span class="comment">//将代码块选中-&gt;ctrl + alt + t -&gt;选中太try-catch</span></span><br><span class="line">        <span class="comment">//如果没有try-catch和throw那么默认使用throw</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> num1 / num2;<span class="comment">//抛出异常，ArithmeticException</span></span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            <span class="comment">//throw new RuntimeException(e);</span></span><br><span class="line">            e.printStackTrace();<span class="comment">//打印异常栈信息</span></span><br><span class="line">            System.out.println(e.getMessage());<span class="comment">//输出异常信息，继续运行</span></span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"程序继续运行"</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*异常体系图的小结</span><br><span class="line">1．异常分为两大类，运行时异常和编译时异常</span><br><span class="line">2．运行时异常，编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该避免其出现的异常。</span><br><span class="line">java.lang.RuntimeException 类及它的子类都是运行时异常</span><br><span class="line">3．对于运行时异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响</span><br><span class="line">4．编译时异常，是编译器要求必须处置的异常。*/</span><br></pre></td></tr></tbody></table></figure><h5 id="常见异常："><a href="#常见异常：" class="headerlink" title="常见异常："></a>常见异常：</h5><h6 id="一、空指针异常：java-lang-NullPointerException"><a href="#一、空指针异常：java-lang-NullPointerException" class="headerlink" title="一、空指针异常：java.lang.NullPointerException"></a>一、空指针异常：java.lang.NullPointerException</h6><p>java中的异常类，当应用程序调用某对象结果为空时，抛出该异常。</p><h6 id="二、类型转换异常：java-lang-ClassCastException"><a href="#二、类型转换异常：java-lang-ClassCastException" class="headerlink" title="二、类型转换异常：java.lang.ClassCastException"></a>二、类型转换异常：java.lang.ClassCastException</h6><p>字面意思，类型不匹配进行转换时所抛出的异常，通常在“向下转型”（父类型转换为子类型，强制类型转换）时发生；<br>解决方法，在需要使用强制类型转换的场景下，添加instanceof运算符，判断左右操作数是否具有继承或实现关系，返回为true时可以进行类型转换。</p><h6 id="三、数组下标越界异常：ArrayIndexOutOfBoundsException"><a href="#三、数组下标越界异常：ArrayIndexOutOfBoundsException" class="headerlink" title="三、数组下标越界异常：ArrayIndexOutOfBoundsException"></a>三、数组下标越界异常：ArrayIndexOutOfBoundsException</h6><p>数组的下标从0开始计数，当遍历数据超出数组长度-1的情况下会抛出数组下标越界异常。</p><h6 id="四、数字格式化异常：NumberFormatException"><a href="#四、数字格式化异常：NumberFormatException" class="headerlink" title="四、数字格式化异常：NumberFormatException"></a>四、数字格式化异常：NumberFormatException</h6><p>// 非数字型不可包装为Integer</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a= <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">"中文"</span>);<span class="comment">//抛出异常</span></span><br><span class="line">Integer a= <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">"123"</span>);<span class="comment">//正常包装</span></span><br></pre></td></tr></tbody></table></figure><h6 id="五、数字异常：ArithmeticException"><a href="#五、数字异常：ArithmeticException" class="headerlink" title="五、数字异常：ArithmeticException"></a>五、数字异常：ArithmeticException</h6><p>除数为0的时候</p><h6 id="六、关于数据库访问错误或其他错误的异常：SQLException（编译时会被发现）"><a href="#六、关于数据库访问错误或其他错误的异常：SQLException（编译时会被发现）" class="headerlink" title="六、关于数据库访问错误或其他错误的异常：SQLException（编译时会被发现）"></a>六、关于数据库访问错误或其他错误的异常：SQLException（编译时会被发现）</h6><h6 id="七、找不到文件：FileNotFoundException（编译时会被发现）"><a href="#七、找不到文件：FileNotFoundException（编译时会被发现）" class="headerlink" title="七、找不到文件：FileNotFoundException（编译时会被发现）"></a>七、找不到文件：FileNotFoundException（编译时会被发现）</h6><h6 id="八、当发生某种I-O异常时：IOException（编译时会被发现）"><a href="#八、当发生某种I-O异常时：IOException（编译时会被发现）" class="headerlink" title="八、当发生某种I/O异常时：IOException（编译时会被发现）"></a>八、当发生某种I/O异常时：IOException（编译时会被发现）</h6><h6 id="九、向方法传递了一个不合法或者不正确的参数（非法传参异常）：IllegalArgumentException"><a href="#九、向方法传递了一个不合法或者不正确的参数（非法传参异常）：IllegalArgumentException" class="headerlink" title="九、向方法传递了一个不合法或者不正确的参数（非法传参异常）：IllegalArgumentException"></a>九、向方法传递了一个不合法或者不正确的参数（非法传参异常）：IllegalArgumentException</h6><h6 id="十、当程序运行被打断时抛出的异常：InterruptedException"><a href="#十、当程序运行被打断时抛出的异常：InterruptedException" class="headerlink" title="十、当程序运行被打断时抛出的异常：InterruptedException"></a>十、当程序运行被打断时抛出的异常：InterruptedException</h6><p>可以打断程序运行的一些方法：<br>java.lang.Object类的wait()方法;<br>java.lang.Thread类的sleep()方法;<br>java.lang.Thread类的Join()方法;<br>原文链接：<a href="https://blog.csdn.net/pxsdbzxj/article/details/127836788">https://blog.csdn.net/pxsdbzxj/article/details/127836788</a></p><h3 id="九-Java的读写方式——IO流读写"><a href="#九-Java的读写方式——IO流读写" class="headerlink" title="九.Java的读写方式——IO流读写"></a>九.Java的读写方式——IO流读写</h3><h5 id="1-IO流，什么是IO？"><a href="#1-IO流，什么是IO？" class="headerlink" title="1.IO流，什么是IO？"></a>1.IO流，什么是IO？</h5><p>I : Input<br>O: Output<br>通过IO可以完成硬盘文件的读和写。</p><h5 id="2-IO流的分类？"><a href="#2-IO流的分类？" class="headerlink" title="2.IO流的分类？"></a>2.IO流的分类？</h5><p>有多种分类方式:</p><h6 id="1-一种方式是按照流的方向进行分类："><a href="#1-一种方式是按照流的方向进行分类：" class="headerlink" title="1)一种方式是按照流的方向进行分类："></a>1)一种方式是按照流的方向进行分类：</h6><p>以内存作为参照物，<br>往内存中去，叫做输入。或者叫做读（Read）。<br>从内存中出来，叫做输出。或者叫做写（Write）。</p><h6 id="2-另一种方式是按照读取数据方式不同进行分类："><a href="#2-另一种方式是按照读取数据方式不同进行分类：" class="headerlink" title="2)另一种方式是按照读取数据方式不同进行分类："></a>2)另一种方式是按照读取数据方式不同进行分类：</h6><p>有的流是按照字节的方式读取数据，一次读取1个字节byte等同于一次读取8个二进制位。<br>这种流是万能的，什么类型的文件都可以读取。包括文本文件、图片、声音文件、视频文件等等…<br>假设文件file1.txt，采用字符流的话是这样读的：<br>a中国bc张三fe<br>第一次读:1个字节，正好读到’a’<br>第二次读:1个字节，正好读到’中’字符的一半<br>第三次都:1个字节，正好读到’中’字符的另外一半</p><p>有的流是按照字符的方式读取数据，一次读取一个字符，这种流是为了方便读取普通文本文件存在的。这种流不能读取:图片、声音、视频等文件，只能读取纯文本文件，连word文件都无法读取。<br>假设文件file1.txt，采用字符流的话是这样读的：<br>a中国bc张三fe<br>第一次读: ‘a’字符（’a’字符在windows系统中占用1个字节）<br>第二次读: ‘中’字符（’中’字符在windows系统中占用2个字节）</p><p>综上所述: 流的分类<br>输入流、输出流（按照流的方向进行分类）<br>字节流、字符流（按照读取的方式进行分类）</p><h5 id="3-IO流都在java-io-包下"><a href="#3-IO流都在java-io-包下" class="headerlink" title="3.IO流都在java.io.*包下"></a>3.IO流都在java.io.*包下</h5><p>java中的IO流都已经写好了，我们程序员不需要关心，我们最主要还是掌握，在java中已经提供了哪些流，每个流的特点是什么，每个流对象上的常用方法有哪些？<br>java中所有的流都是在: java.io.*下。</p><p>java中主要还是研究:<br>怎么new流对象。<br>调用流对象的哪个方法是读，哪个方法是写。</p><h5 id="4-java-IO流有四个家族"><a href="#4-java-IO流有四个家族" class="headerlink" title="4.java IO流有四个家族"></a>4.java IO流有四个家族</h5><p>java.io.InputStream 字节输入流<br>java.io.OutputStream 字节输出流</p><p>java.io.Reader 字符输入流<br>java.io.Writer 字符输出流</p><p>注意: 在java中只要”类名”以Stream结尾的都是字节流。以”Reader/Writer”结尾的都是字符流。</p><h5 id="5-java-io包下需要掌握的流有16个"><a href="#5-java-io包下需要掌握的流有16个" class="headerlink" title="5.java.io包下需要掌握的流有16个"></a>5.java.io包下需要掌握的流有16个</h5><h6 id="文件专属"><a href="#文件专属" class="headerlink" title="文件专属:"></a>文件专属:</h6><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.io.FileInputStream</span><br><span class="line">java.io.FileOutputStream</span><br><span class="line">java.io.FileReader</span><br><span class="line">java.io.FileWriter</span><br></pre></td></tr></tbody></table></figure><h6 id="转换流-（将字节流转换成字符流）"><a href="#转换流-（将字节流转换成字符流）" class="headerlink" title="转换流:（将字节流转换成字符流）"></a>转换流:（将字节流转换成字符流）</h6><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.io.InputStreamReader</span><br><span class="line">java.io.OutputStreamWriter</span><br></pre></td></tr></tbody></table></figure><h6 id="缓冲流专属"><a href="#缓冲流专属" class="headerlink" title="缓冲流专属:"></a>缓冲流专属:</h6><p>java.io.BufferedReader<br>java.io.BufferedWriter<br>java.io.BufferedInputStream<br>java.io.BufferedOutputStream</p><h6 id="数据流专属"><a href="#数据流专属" class="headerlink" title="数据流专属:"></a>数据流专属:</h6><p>java.io.DateInputStream<br>java.io.DateOutputStream</p><h6 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流:"></a>标准输出流:</h6><p>java.io.printWriter<br>java.io.printStream</p><h6 id="对象专属流"><a href="#对象专属流" class="headerlink" title="对象专属流:"></a>对象专属流:</h6><p>java.io.ObjectInputStream<br>java.io.ObjectOutputStream</p><h5 id="6-FileInputStream的1个字节读入法"><a href="#6-FileInputStream的1个字节读入法" class="headerlink" title="6.FileInputStream的1个字节读入法"></a>6.FileInputStream的1个字节读入法</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jmpower.javase.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.io.FileInputStream:</span></span><br><span class="line"><span class="comment">    1.文件字节输入流，万能的，任何类型的文件都可以采用这个流来读。</span></span><br><span class="line"><span class="comment">    2.字节的方式，完成输入的操作，完成读的操作。(硬盘--&gt;内存)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamTest01</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        FileInputStream fis=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//创建字节输入流对象</span></span><br><span class="line">            <span class="comment">//文件路径:C:\Users\Jm\Desktop\Java\doSome.txt</span></span><br><span class="line">            <span class="comment">//文件内容为:abcedf</span></span><br><span class="line">            <span class="comment">//FileInputStream fis=new FileInputStream("C:\\Users\\Jm\\Desktop\\Java\\doSome.txt");</span></span><br><span class="line">            <span class="comment">//都采用了: 绝对路径</span></span><br><span class="line">            <span class="comment">//将"\\"写成"/"也是可以的</span></span><br><span class="line">            fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"C:/Users/Jm/Desktop/Java/doSome.txt"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> readDate=fis.read();<span class="comment">//这个方法的返回值是读到字节本身</span></span><br><span class="line">            System.out.println(readDate);<span class="comment">// 97</span></span><br><span class="line">    </span><br><span class="line">        } <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">//在finally语句块中确保流一定要关闭</span></span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="literal">null</span>) {</span><br><span class="line">                <span class="comment">//关闭流的前提是:流不是空。流是null的时候没必要关闭。</span></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    fis.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="7-FileInputStream的byte-读入法"><a href="#7-FileInputStream的byte-读入法" class="headerlink" title="7.FileInputStream的byte[]读入法"></a>7.FileInputStream的byte[]读入法</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jmpower.javase.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int read(byte[] b)</span></span><br><span class="line"><span class="comment">    一次最多读取b.length个字节。</span></span><br><span class="line"><span class="comment">    减少硬盘和内存之间的交互，提高程序的执行效率。</span></span><br><span class="line"><span class="comment">    往byte[]数组当中读。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamTest02</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        FileInputStream fis=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//相对路径的话呢？相对路径一定是从当前所在的位置作为起点开始找！</span></span><br><span class="line">            <span class="comment">//IDEA默认的当前路径是工程Object的根就是IDEA的默认当前路径。</span></span><br><span class="line">            <span class="comment">//文件内容:abcdef</span></span><br><span class="line">            fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"text02.txt"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] bytes=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];<span class="comment">//准备一个4个长度的byte数组，一次最多读取4个字节。</span></span><br><span class="line">            <span class="comment">//这个方法的返回值是，读取到的字节数量。（不是字节本身）</span></span><br><span class="line">            <span class="comment">//int readCount=fis.read(bytes);</span></span><br><span class="line">            <span class="comment">//System.out.println(readCount);// 第一次读到4个字节</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">//将字节数组全部转换成字符串</span></span><br><span class="line">            <span class="comment">//System.out.println(new String(bytes));</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">//不应该全部转换，应该读取了多少个字节，转换多少个。</span></span><br><span class="line">            <span class="comment">//System.out.println(new String(bytes,0,readCount));// abcd</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">//最终版本，读取文件</span></span><br><span class="line">            <span class="type">int</span> readCount=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((readCount = fis.read(bytes))!=-<span class="number">1</span>)</span><br><span class="line">            {</span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,readCount));</span><br><span class="line">            }</span><br><span class="line">    </span><br><span class="line">        } <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    fis.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="8-FileInputStream的其他方法"><a href="#8-FileInputStream的其他方法" class="headerlink" title="8.FileInputStream的其他方法"></a>8.FileInputStream的其他方法</h5><h6 id="1）int-available-返回流当中剩余的没有读取到的字节的数量"><a href="#1）int-available-返回流当中剩余的没有读取到的字节的数量" class="headerlink" title="1）int available(): 返回流当中剩余的没有读取到的字节的数量"></a>1）int available(): 返回流当中剩余的没有读取到的字节的数量</h6><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jmpower.javase.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamTest03</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        FileInputStream fis=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"test03"</span>);</span><br><span class="line">            System.out.println(<span class="string">"总字节数量:"</span>+fis.available());<span class="comment">// 41</span></span><br><span class="line">            <span class="comment">//读一个字节</span></span><br><span class="line">            <span class="comment">//int readDate=fis.read();</span></span><br><span class="line">            <span class="comment">//还剩下的可读字节为40</span></span><br><span class="line">            <span class="comment">//System.out.println("还剩下的可读字节的数量:"+fis.available());// 40</span></span><br><span class="line">            <span class="comment">//这个方法有什么用？</span></span><br><span class="line">            <span class="type">byte</span>[] bytes=<span class="keyword">new</span> <span class="title class_">byte</span>[fis.available()];</span><br><span class="line">            <span class="comment">//不需要循环了！</span></span><br><span class="line">            <span class="comment">//直接读一次就行了。</span></span><br><span class="line">            <span class="type">int</span> readCount=fis.read(bytes);<span class="comment">// 6</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes)); <span class="comment">// abcdef</span></span><br><span class="line">        } <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    fis.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="2）long-stip-long-n-跳过几个字节不读"><a href="#2）long-stip-long-n-跳过几个字节不读" class="headerlink" title="2）long stip(long n): 跳过几个字节不读"></a>2）long stip(long n): 跳过几个字节不读</h6><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jmpower.javase.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamTest04</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        FileInputStream fis=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"text02.txt"</span>);</span><br><span class="line">            <span class="comment">//a   b  c  d   e   f</span></span><br><span class="line">            <span class="comment">//97 98 99 100 101 102</span></span><br><span class="line">            System.out.println(fis.read());<span class="comment">// 97</span></span><br><span class="line">            fis.skip(<span class="number">3</span>);<span class="comment">//跳过三个字节</span></span><br><span class="line">            System.out.println(fis.read());<span class="comment">// 101</span></span><br><span class="line">        } <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    fis.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="9-FileOutputStream用法"><a href="#9-FileOutputStream用法" class="headerlink" title="9.FileOutputStream用法"></a>9.FileOutputStream用法</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jmpower.javase.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamTest01</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        FileOutputStream fos=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//file01文件不存在会自动新建！</span></span><br><span class="line">            <span class="comment">//这种方式慎用，这种方式会先将文件清空，然后重新写入。</span></span><br><span class="line">            <span class="comment">//fos=new FileOutputStream("file01");</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//以追加的方式在文件末尾写入。不会清空原文件的内容。</span></span><br><span class="line">            fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"text02.txt"</span>,<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//开始写</span></span><br><span class="line">            <span class="type">byte</span>[] bytes={<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>};</span><br><span class="line">            <span class="comment">//将byte数组全部写出！</span></span><br><span class="line">            fos.write(bytes);<span class="comment">// abcd</span></span><br><span class="line">            <span class="comment">//将bute数组的一部分写出！</span></span><br><span class="line">            fos.write(bytes,<span class="number">0</span>,<span class="number">2</span>);<span class="comment">// ab</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">//字符串</span></span><br><span class="line">            String s=<span class="string">"我是中国人！"</span>;</span><br><span class="line">            <span class="comment">//将字符串转换成数组</span></span><br><span class="line">            <span class="type">byte</span>[] bs=s.getBytes();</span><br><span class="line">            <span class="comment">//写</span></span><br><span class="line">            fos.write(bs);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">//写完之后一定要刷新</span></span><br><span class="line">            fos.flush();</span><br><span class="line">        } <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    fos.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="10-文件复制"><a href="#10-文件复制" class="headerlink" title="10.文件复制"></a>10.文件复制</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jmpower.javase.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用FileInputStream + FileOutputStream完成文件的拷贝。</span></span><br><span class="line"><span class="comment">拷贝的过程一定是一边读，一边写。</span></span><br><span class="line"><span class="comment">使用以上的字节流拷贝文件的时候，文件类型随意，万能的。什么样的文件都可以拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Copy01</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        FileInputStream fis=<span class="literal">null</span>;</span><br><span class="line">        FileOutputStream fos=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//创建一个输入流对象</span></span><br><span class="line">            fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"C:\\Users\\Jm\\Pictures\\自建\\十三届蓝桥杯省一.jpg"</span>);</span><br><span class="line">            <span class="comment">//创建一个输出流对象</span></span><br><span class="line">            fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"C:\\Users\\Jm\\Desktop\\Java\\十三届蓝桥杯省一.jpg"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//最核心的: 一边读，一边写</span></span><br><span class="line">            <span class="type">byte</span>[] bytes=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];<span class="comment">//1MB（一次最多拷贝1MB）</span></span><br><span class="line">            <span class="type">int</span> readCount=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((readCount=fis.read(bytes))!=-<span class="number">1</span>)</span><br><span class="line">            {</span><br><span class="line">                fos.write(bytes,<span class="number">0</span>,readCount);</span><br><span class="line">            }</span><br><span class="line">    </span><br><span class="line">            <span class="comment">//刷新，输出流最后要刷新</span></span><br><span class="line">            fos.flush();</span><br><span class="line">        } <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">//分开try，不要一起try</span></span><br><span class="line">            <span class="comment">//一起try的时候，其中一个出现异常，可能会影响到另一个流的关闭</span></span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    fis.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    fos.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="11-FileReader用法"><a href="#11-FileReader用法" class="headerlink" title="11.FileReader用法"></a>11.FileReader用法</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jmpower.javase.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">FileReader:</span></span><br><span class="line"><span class="comment">    读取文本内容时，比较方便，快捷。</span></span><br><span class="line"><span class="comment">    一次读取一个字符。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        FileReader reader=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//创建文件字符输入流</span></span><br><span class="line">            reader=<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">"text02.txt"</span>);</span><br><span class="line">            <span class="comment">//开始读</span></span><br><span class="line">            <span class="type">char</span>[] chars=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">4</span>];<span class="comment">//一次读取4个字符(1个字符2个字节)</span></span><br><span class="line">            <span class="type">int</span> readCount=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((readCount=reader.read(chars))!=-<span class="number">1</span>)</span><br><span class="line">            {</span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(chars,<span class="number">0</span>,readCount));</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span> (reader != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    reader.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="12-复制普通文本文件（Reader-Writer）"><a href="#12-复制普通文本文件（Reader-Writer）" class="headerlink" title="12.复制普通文本文件（Reader/Writer）"></a>12.复制普通文本文件（Reader/Writer）</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jmpower.javase.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Copy02</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        FileReader in=<span class="literal">null</span>;</span><br><span class="line">        FileWriter out=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//读</span></span><br><span class="line">            in=<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">"src/com/jmpower/javase/io/FileInputStreamTest02.java"</span>);</span><br><span class="line">            <span class="comment">//写</span></span><br><span class="line">            out=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">"reader"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//一边读一边写</span></span><br><span class="line">            <span class="type">char</span>[] chars=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>*<span class="number">512</span>];<span class="comment">//1MB</span></span><br><span class="line">            <span class="type">int</span> readCount=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((readCount=in.read(chars))!=-<span class="number">1</span>)</span><br><span class="line">            {</span><br><span class="line">                out.write(<span class="keyword">new</span> <span class="title class_">String</span>(chars,<span class="number">0</span>,readCount));</span><br><span class="line">            }</span><br><span class="line">    </span><br><span class="line">            <span class="comment">//刷新</span></span><br><span class="line">            out.flush();</span><br><span class="line">        } <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">//关闭流</span></span><br><span class="line">            <span class="keyword">if</span> (in != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    in.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    out.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="13-带有缓冲区的字符输入流"><a href="#13-带有缓冲区的字符输入流" class="headerlink" title="13.带有缓冲区的字符输入流"></a>13.带有缓冲区的字符输入流</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jmpower.javase.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BufferedReader:</span></span><br><span class="line"><span class="comment">    带有缓冲区的字符输入流。</span></span><br><span class="line"><span class="comment">    使用这个流的时候不需要自定义char数组，或者说不需要自定义byte数组。自带缓冲。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReaderTest01</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        FileReader reader=<span class="literal">null</span>;</span><br><span class="line">        BufferedReader br=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            reader=<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">"src/com/jmpower/javase/io/Copy02.java"</span>);</span><br><span class="line">            <span class="comment">//当一个流的构造方法中需要一个流的时候，这个被传进来的流叫做: 节点流。</span></span><br><span class="line">            <span class="comment">//外部负责包装的这个流，叫做: 包装流，还有一个名字叫做: 处理流。</span></span><br><span class="line">            <span class="comment">//像当前这个程序来说: FileReader叫做一个节点流。BufferedReader就是包装流/处理流。</span></span><br><span class="line">            br=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(reader);</span><br><span class="line">            <span class="comment">/*//第一行</span></span><br><span class="line"><span class="comment">            String firstLine=br.readLine();</span></span><br><span class="line"><span class="comment">            System.out.println(firstLine);</span></span><br><span class="line"><span class="comment">            //第二行</span></span><br><span class="line"><span class="comment">            String secondLine=br.readLine();</span></span><br><span class="line"><span class="comment">            System.out.println(secondLine);*/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//br.readLine()方法读取一个文本行，但不带换行符。</span></span><br><span class="line">            String line=<span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span>((line=br.readLine())!=<span class="literal">null</span>)</span><br><span class="line">            {</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            }</span><br><span class="line">    </span><br><span class="line">        } <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">//关闭流</span></span><br><span class="line">            <span class="comment">//对于包装流来说，只需要关闭最外层流就行，里面的节点流会自动关闭。（可以看源代码）</span></span><br><span class="line">            <span class="keyword">if</span> (br != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    br.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="14-包装流和节点流（即转换流）"><a href="#14-包装流和节点流（即转换流）" class="headerlink" title="14.包装流和节点流（即转换流）"></a>14.包装流和节点流（即转换流）</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jmpower.javase.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReaderTest02</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        BufferedReader br=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//字节流</span></span><br><span class="line">            FileInputStream in=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"src/com/jmpower/javase/io/Copy02.java"</span>);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">//通过转换流转换(InputStreamReader将字节流转换成字符流)</span></span><br><span class="line">            <span class="comment">//in是节点流。reader是包装流。</span></span><br><span class="line">            InputStreamReader reader=<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">//这个构造方法只能传一个字符流。不能传字节流。</span></span><br><span class="line">            <span class="comment">//reader是节点流。br是包装流。</span></span><br><span class="line">            br=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(reader);</span><br><span class="line">    </span><br><span class="line">            String line=<span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span>((line=br.readLine())!=<span class="literal">null</span>)</span><br><span class="line">            {</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            }</span><br><span class="line">    </span><br><span class="line">        } <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">//关闭最外层</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                br.close();</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>15.带有缓冲区的字符输出流</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jmpower.javase.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BufferedWriter: 带有缓冲的字符输出流</span></span><br><span class="line"><span class="comment">OutputStreamWriter: 转换流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedWriterTest01</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        BufferedWriter out=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//带有缓冲的字符输出流</span></span><br><span class="line">            <span class="comment">//out=new BufferedWriter(new FileWriter("bo"));</span></span><br><span class="line">            out=<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"doSome"</span><span class="comment">/*,true*/</span>)));</span><br><span class="line">            <span class="comment">//开始写</span></span><br><span class="line">            out.write(<span class="string">"123"</span>);</span><br><span class="line">            out.write(<span class="string">"\n"</span>);</span><br><span class="line">            out.write(<span class="string">"456"</span>);</span><br><span class="line">            <span class="comment">//刷新（输出流记得刷新）</span></span><br><span class="line">            out.flush();</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    out.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="16-数据流"><a href="#16-数据流" class="headerlink" title="16.数据流"></a>16.数据流</h5><h6 id="1）写"><a href="#1）写" class="headerlink" title="1）写"></a>1）写</h6><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jmpower.javase.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.io.DataOutputStream:数据专属的流</span></span><br><span class="line"><span class="comment">这个流可以将数据连通数据的类型一并写入文件。</span></span><br><span class="line"><span class="comment">注意: 这个文件不是普通文本文档。（这个文件使用记事本打不开）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataOutputStreamTest01</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        DataOutputStream dos=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//创建数据专属的字节输出流</span></span><br><span class="line">            dos=<span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"data"</span>));</span><br><span class="line">            <span class="comment">//写数据</span></span><br><span class="line">            <span class="type">byte</span> b=<span class="number">100</span>;</span><br><span class="line">            <span class="type">short</span> s=<span class="number">400</span>;</span><br><span class="line">            <span class="type">int</span> i=<span class="number">200</span>;</span><br><span class="line">            <span class="type">long</span> l=<span class="number">300</span>;</span><br><span class="line">            <span class="type">float</span> f=<span class="number">3.0f</span>;</span><br><span class="line">            <span class="type">double</span> d=<span class="number">3.14</span>;</span><br><span class="line">            <span class="type">boolean</span> sex=<span class="literal">false</span>;</span><br><span class="line">            <span class="type">char</span> c=<span class="string">'0'</span>;</span><br><span class="line">            <span class="comment">//写</span></span><br><span class="line">            dos.writeByte(b);</span><br><span class="line">            dos.writeShort(s);</span><br><span class="line">            dos.writeInt(i);</span><br><span class="line">            dos.writeLong(l);</span><br><span class="line">            dos.writeFloat(f);</span><br><span class="line">            dos.writeDouble(d);</span><br><span class="line">            dos.writeBoolean(sex);</span><br><span class="line">            dos.writeChar(c);</span><br><span class="line">            <span class="comment">//刷新</span></span><br><span class="line">            dos.flush();</span><br><span class="line">        } <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span> (dos != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    dos.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="2）读"><a href="#2）读" class="headerlink" title="2）读"></a>2）读</h6><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jmpower.javase.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.io.DataInputStream: 数据字节输入流</span></span><br><span class="line"><span class="comment">DataOutputStream写的文件，只能使用DataInputStream去读。并且读的时候你需要提前知道写入的顺序。</span></span><br><span class="line"><span class="comment">读的顺序需要和谐的顺序一致。才可以正常读出数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataInputStreamTest01</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        DataInputStream dis=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            dis=<span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"data"</span>));</span><br><span class="line">            <span class="comment">//开始读</span></span><br><span class="line">            <span class="type">byte</span> b=dis.readByte();</span><br><span class="line">            <span class="type">short</span> s=dis.readShort();</span><br><span class="line">            <span class="type">int</span> i=dis.readInt();</span><br><span class="line">            <span class="type">long</span> l=dis.readLong();</span><br><span class="line">            <span class="type">float</span> f= dis.readFloat();</span><br><span class="line">            <span class="type">double</span> d= dis.readDouble();</span><br><span class="line">            <span class="type">boolean</span> sex= dis.readBoolean();</span><br><span class="line">            <span class="type">char</span> c= dis.readChar();</span><br><span class="line"></span><br><span class="line">            System.out.println(b);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            System.out.println(l);</span><br><span class="line">            System.out.println(f);</span><br><span class="line">            System.out.println(d);</span><br><span class="line">            System.out.println(sex);</span><br><span class="line">            System.out.println(c);</span><br><span class="line">            </span><br><span class="line">        } <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span> (dis != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    dis.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="17-标准输出流"><a href="#17-标准输出流" class="headerlink" title="17.标准输出流"></a>17.标准输出流</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jmpower.javase.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.io.PrintStream: 标准的字节输出流。默认输出到控制台。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStreamTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//联合起来写</span></span><br><span class="line">        System.out.println(<span class="string">"hello world!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分开写</span></span><br><span class="line">        java.io.PrintStream ps=System.out;</span><br><span class="line">        ps.println(<span class="string">"hello zhangsan"</span>);</span><br><span class="line">        ps.println(<span class="string">"hello lisi"</span>);</span><br><span class="line">        ps.println(<span class="string">"hello wangwu"</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//标准输出流不需要手动colse()关闭。</span></span><br><span class="line">        <span class="comment">//可以改变标准输出流的输出方向吗？可以</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//标准输出流不再指向控制台，指向“log”文件</span></span><br><span class="line">            PrintStream printStream=<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"log"</span>));</span><br><span class="line">            <span class="comment">//修改输出方向，将输出方向修改到"log"文件</span></span><br><span class="line">            System.setOut(printStream);</span><br><span class="line">            <span class="comment">//再输出，输入到了"log"文件中</span></span><br><span class="line">            System.out.println(<span class="string">"hello lisi"</span>);</span><br><span class="line">            System.out.println(<span class="string">"hello zhangsan"</span>);</span><br><span class="line">            System.out.println(<span class="string">"hello wangwu"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>原文链接：<a href="https://blog.csdn.net/m0_66689823/article/details/125881759">https://blog.csdn.net/m0_66689823/article/details/125881759</a></p><h5 id="18-read，readline，writer，newline"><a href="#18-read，readline，writer，newline" class="headerlink" title="18.read，readline，writer，newline"></a>18.read，readline，writer，newline</h5><h6 id="read-方法读取输入流"><a href="#read-方法读取输入流" class="headerlink" title="read()方法读取输入流"></a>read()方法读取输入流</h6><p>read()方法读取的是单个字符，也可以说只要有输入流就会一直读取，返回的值是：作为一个整数（其范围从 0 到 65535 (0x00-0xffff)）读入的字符，如果已到达流末尾，则返回 -1</p><p>因此使用该方法时应该尽量避免输入流数据重复的发送，这样会导致read()读取到很长的重复数据，导致读取超时，但是对于仅有单次发送的输入流，则可以使用read()方法，具体使用如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> client.getInputStream(); <span class="comment">//获取到客户端的输入流</span></span><br><span class="line"><span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">//定义字节数组</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(b); <span class="comment">//由于信息的传输是以二进制的形式，所以要以二进制的形式进行数据的读取</span></span><br><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>,len);</span><br><span class="line">System.out.println(<span class="string">"输入流消息："</span> + data);</span><br></pre></td></tr></tbody></table></figure><h6 id="Readline-方法读取输入流"><a href="#Readline-方法读取输入流" class="headerlink" title="Readline()方法读取输入流"></a>Readline()方法读取输入流</h6><p>readLine方法读取一个是文本行。通过下列字符之一即可认为某行已终止：换行 (‘\n’)、回车 (‘\r’) 或回车后直接跟着换行。 返回的值是：包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null</p><p>也就是说只要readLine方法读取到的输入流中含有回车换行符，则读取结束，这样的话对于连续重复发送的输入流信息，我们可以在每条信息的末尾增加一个回车换行符，这样readLine方法读取到该符号时就会自动结束，</p><p>具体使用如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream(), <span class="string">"gb2312"</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> br.readLine();</span><br><span class="line"><span class="keyword">if</span>(msg != <span class="literal">null</span>) {</span><br><span class="line">    System.out.println(<span class="string">"收到输入流信息："</span> + msg + <span class="string">"\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>原文链接：<a href="https://blog.csdn.net/weixin_44985880/article/details/109729502">https://blog.csdn.net/weixin_44985880/article/details/109729502</a></p><h6 id="Writer类的构造函数"><a href="#Writer类的构造函数" class="headerlink" title="Writer类的构造函数"></a>Writer类的构造函数</h6><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">创建一个字符流writer,将同步 writer 自身</span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">Writer</span><span class="params">()</span></span><br><span class="line">创建一个字符流 writer,将同步给定的对象</span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">Writer</span><span class="params">(Object lock)</span></span><br><span class="line">Writer类的方法</span><br><span class="line"></span><br><span class="line">Writer <span class="title function_">append</span><span class="params">(<span class="type">char</span> c)</span> 将指定字符添加到此 writer</span><br><span class="line">Writer <span class="title function_">append</span><span class="params">(CharSequence csq)</span> 将指定字符序列添加到此 writer</span><br><span class="line">Writer <span class="title function_">append</span><span class="params">(CharSequence csq, <span class="type">int</span> start, <span class="type">int</span> end)</span> 将指定字符序列的子序列添加到此 writer.Appendable</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> 关闭此流，但要先刷新它</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span> 刷新该流的缓冲</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] cbuf)</span> 写入字符数组</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] cbuf, <span class="type">int</span> off, <span class="type">int</span> len)</span> 写入字符数组的某一部分</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span> 写入单个字符</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str)</span> 写入字符串</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str, <span class="type">int</span> off, <span class="type">int</span> len)</span> 写入字符串的某一部分</span><br><span class="line">Writer类图</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Writer常见的实现子类</span><br><span class="line"></span><br><span class="line">BufferedWriter   字符缓冲输出流</span><br><span class="line">FileWriter   用来写入字符串到文件</span><br><span class="line">OutputStreamWriter 写入字符，同时可以设置编码集</span><br><span class="line">例</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception{ </span><br><span class="line">        <span class="comment">//使用File类找到一个文件</span></span><br><span class="line">        File f= <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">"d:"</span> + File.separator + <span class="string">"java265.txt"</span>) ; </span><br><span class="line">        <span class="comment">//通过子类实例化父类对象</span></span><br><span class="line">        <span class="type">Writer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span> ;    <span class="comment">// 准备好一个输出的对象</span></span><br><span class="line">        out = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(f)  ;    <span class="comment">// 通过对象多态性，进行实例化   </span></span><br><span class="line">        <span class="comment">// 进行写操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">"java265.com 最好的java网站"</span> ;        <span class="comment">// 准备一个字符串</span></span><br><span class="line">        out.write(str) ;                        <span class="comment">// 将内容输出，保存文件</span></span><br><span class="line">        <span class="comment">//关闭输出流</span></span><br><span class="line">        out.close() ;                        <span class="comment">// 关闭输出流 </span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>原文链接：<a href="https://blog.csdn.net/qq_25073223/article/details/126259445">https://blog.csdn.net/qq_25073223/article/details/126259445</a></p><h6 id="newline"><a href="#newline" class="headerlink" title="newline"></a>newline</h6><p>[英]Put the line separator String onto the print stream.<br>[中]将行分隔符字符串放入打印流。</p><ol><li><p>newLine()与\r\n的区别</p></li><li><p>newLine()是跨平台的方法</p></li><li><p>\r\n只支持的是windows系统</p><h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><h5 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h5><p>Java 的控制台输入由 System.in 完成。</p><p>为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。</p><p>下面是创建 BufferedReader 的基本语法：</p><p>BufferedReader br = new BufferedReader(new   InputStreamReader(System.in));</p><p>BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。</p><hr><h5 id="从控制台读取多字符输入"><a href="#从控制台读取多字符输入" class="headerlink" title="从控制台读取多字符输入"></a>从控制台读取多字符输入</h5><p>从 BufferedReader 对象读取一个字符要使用 read() 方法，它的语法如下：</p><p>int read( ) throws IOException</p><p>每次调用 read() 方法，它从输入流读取一个字符并把该字符作为整数值返回。 当流结束的时候返回 -1。该方法抛出 IOException。</p><p>下面的程序示范了用 read() 方法从控制台不断读取字符直到用户输入 <strong>q</strong>。</p><h5 id="BRRead-java-文件代码："><a href="#BRRead-java-文件代码：" class="headerlink" title="BRRead.java 文件代码："></a>BRRead.java 文件代码：</h5><p>//使用 BufferedReader 在控制台读取字符</p><p> import java.io.*; </p><p> public class BRRead {</p><p>​        public static void main(String[] args) throws IOException { </p><p>​        char c;       </p><p>​        // 使用 System.in 创建 BufferedReader       </p><p>​        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</p><p>​        System.out.println(“输入字符, 按下 ‘q’ 键退出。”);</p><p>​        // 读取字符       </p><p>​        do {           </p><p>​                   c = (char) br.read();</p><p>​                   System.out.println(c);        </p><p>​               } while (c != ‘q’);    } }</p></li></ol><h3 id="十-多线程"><a href="#十-多线程" class="headerlink" title="十.多线程"></a>十.多线程</h3><h4 id="1-线程"><a href="#1-线程" class="headerlink" title="1 - 线程"></a>1 - 线程</h4><h5 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1 - 进程"></a>1.1 - 进程</h5><p>   进程就是正在运行中的程序（进程是驻留在内存中的）</p><p>   是系统执行资源分配和调度的独立单位</p><p>   每一进程都有属于自己的存储空间和系统资源</p><p>   注意：进程A和进程B的内存独立不共享。</p><h5 id="1-2-线程"><a href="#1-2-线程" class="headerlink" title="1.2 - 线程"></a>1.2 - 线程</h5><p>   线程就是进程中的单个顺序控制流，也可以理解成是一条执行路径</p><p>   单线程：一个进程中包含一个顺序控制流（一条执行路径）</p><p>   多线程：一个进程中包含多个顺序控制流（多条执行路径）</p><p>   在java语言中：<br>    线程A和线程B，堆内存和方法区内存共享。<br>    但是栈内存独立，一个线程一个栈。</p><p>   假设启动10个线程，会有10个栈空间，每个栈和每个栈之间，互不干扰，各自执行各自的，这就是多线程并发。</p><p>   java中之所以有多线程机制，目的就是为了提高程序的处理效率。</p><p>   对于单核的CPU来说，不能够做到真正的多线程并发，但是可以做到给人一种“多线程并发”的感觉。对于单核的CPU来说，在某一个时间点上实际上只能处理一件事情，但是由于CPU的处理速度极快，多个线程之间频繁切换执行，跟人来的感觉是多个事情同时在做。</p><p>   <img src="https://img-blog.csdnimg.cn/f86be0ff79da458eb3d852b27a8c119b.png" alt="img"></p><h5 id="1-3-java中多线程的实现原理"><a href="#1-3-java中多线程的实现原理" class="headerlink" title="1.3 -java中多线程的实现原理"></a>1.3 -java中多线程的实现原理</h5><p>   <img src="https://img-blog.csdnimg.cn/36a712dbdff642048611a26849294d1e.png" alt="img"></p><pre><code>就绪状态：就绪状态的线程又叫做可运行状态，表示当前线程具有抢夺CPU时间片的权力（CPU时间片就是执行权）。当一个线程抢夺到CPU时间片之后，就开始执行run方法，run方法的开始执行标志着线程进入运行状态。</code></pre><p>   运行状态：run方法的开始执行标志着这个线程进入运行状态，当之前占有的CPU时间片用完之后，会重新回到就绪状态继续抢夺CPU时间片，当再次抢到CPU时间之后，会重新进入run方法接着上一次的代码继续往下执行。</p><p>   阻塞状态：当一个线程遇到阻塞事件，例如接收用户键盘输入，或者sleep方法等，此时线程会进入阻塞状态，阻塞状态的线程会放弃之前占有的CPU时间片。之前的时间片没了需要再次回到就绪状态抢夺CPU时间片。</p><p>   锁池：在这里找共享对象的对象锁线程进入锁池找共享对象的对象锁的时候，会释放之前占有CPU时间片，有可能找到了，有可能没找到，没找到则在锁池中等待，如果找到了会进入就绪状态继续抢夺CPU时间片。（这个进入锁池，可以理解为一种阻塞状态）</p><h5 id="1-4-多线程的实现方式（一）"><a href="#1-4-多线程的实现方式（一）" class="headerlink" title="1.4 - 多线程的实现方式（一）"></a>1.4 - 多线程的实现方式（一）</h5><p>   继承Thread类</p><p>   1、自定义一个类MyThread类，用来继承与Thread类</p><p>   2、在MyThread类中重写run（）方法</p><p>   3、在测试类中创建MyThread类的对象</p><p>   4、启动线程</p><pre><code>* ```java/**    * @author Mr.乐       * @Description      */      public class Demo01 {   public static void main(String[] args) {          //创建线程       MyThread t01 = new MyThread();       MyThread t02 = new MyThread();       MyThread t03 = new MyThread("线程03");             //开启线程         //        t01.run();      //        t02.run();      //        t03.run();          // 不会启动线程，不会分配新的分支栈。（这种方式就是单线程。）          // start()方法的作用是：启动一个分支线程，在JVM中开辟一个新的栈空间，这段代码任务完成之后，瞬间就结束了。          // 这段代码的任务只是为了开启一个新的栈空间，只要新的栈空间开出来，start()方法就结束了。线程就启动成功了。          // 启动成功的线程会自动调用run方法，并且run方法在分支栈的栈底部（压栈）。          // run方法在分支栈的栈底部，main方法在主栈的栈底部。run和main是平级的。          t01.start();          t02.start();          t03.start();          //设置线程名（补救的设置线程名的方式）          t01.setName("线程01");          t02.setName("线程02");          //设置主线程名称       Thread.currentThread().setName("主线程");       for (int i = 0; i &lt; 50; i++) {              //Thread.currentThread() 获取当前正在执行线程的对象              System.out.println(Thread.currentThread().getName() + ":" + i);       }      }      }      class MyThread extends Thread{   public MyThread() {      }         public MyThread(String name) {          super(name);      }         //run方法是每个线程运行过程中都必须执行的方法   @Override   public void run() {       for (int i = 0; i &lt; 50; i++) {           System.out.println(this.getName() + ":" + i);       }   }   }<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    此处最重要的为start()方法。单纯调用run()方法不会启动线程，不会分配新的分支栈。</span><br><span class="line"></span><br><span class="line">   start()方法的作用是：启动一个分支线程，在JVM中开辟一个新的栈空间，这段代码任务完成之后，瞬间就结束了。线程就启动成功了。</span><br><span class="line"></span><br><span class="line">   启动成功的线程会自动调用run方法（由JVM线程调度机制来运作的），并且run方法在分支栈的栈底部（压栈）。</span><br><span class="line"></span><br><span class="line">   run方法在分支栈的栈底部，main方法在主栈的栈底部。run和main是平级的。</span><br><span class="line"></span><br><span class="line">   单纯使用run()方法是不能多线程并发的。</span><br><span class="line"></span><br><span class="line">   ##### 1.5 - 设置和获取线程名</span><br><span class="line"></span><br><span class="line">   设置线程名</span><br><span class="line"></span><br><span class="line">   setName(String name):设置线程名</span><br><span class="line"></span><br><span class="line">   通过带参构造方法设置线程名</span><br><span class="line"></span><br><span class="line">   获取线程名</span><br><span class="line"></span><br><span class="line">   getName()：返回字符串形式的线程名</span><br><span class="line"></span><br><span class="line">   Thread.CurrentThread():返回当前正在执行的线程对象</span><br><span class="line"></span><br><span class="line">   ##### 1.6 - 多线程的实现方式（二）</span><br><span class="line"></span><br><span class="line">   实现Runnable接口</span><br><span class="line"></span><br><span class="line">   1、自定义一个MyRunnable类来实现Runnable接口</span><br><span class="line"></span><br><span class="line">   2、在MyRunnable类中重写run（）方法</span><br><span class="line"></span><br><span class="line">   3、创建Thread对象，并把MyRunnable对象作为Tread类构造方法的参数传递进去</span><br><span class="line"></span><br><span class="line">   4、启动线程</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">* ```java</span><br><span class="line">/**</span><br><span class="line"></span><br><span class="line">    * @author Mr.乐</span><br><span class="line">    * @Description</span><br><span class="line">      */</span><br><span class="line">      public class Demo02 {</span><br><span class="line">      public static void main(String[] args) {</span><br><span class="line">          MyRunnable myRun = new MyRunnable();//将一个任务提取出来，让多个线程共同去执行</span><br><span class="line">          //封装线程对象</span><br><span class="line">          Thread t01 = new Thread(myRun, "线程01");</span><br><span class="line">          Thread t02 = new Thread(myRun, "线程02");</span><br><span class="line">          Thread t03 = new Thread(myRun, "线程03");</span><br><span class="line">          //开启线程</span><br><span class="line">          t01.start();</span><br><span class="line">          t02.start();</span><br><span class="line">          t03.start();</span><br><span class="line">          //通过匿名内部类的方式创建线程</span><br><span class="line">          new Thread(new Runnable() {</span><br><span class="line">              @Override</span><br><span class="line">              public void run() {</span><br><span class="line">                  for (int i = 0; i &lt; 20; i++) {</span><br><span class="line">                      System.out.println(Thread.currentThread().getName() + " - " + i);</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       },"线程04").start();</span><br><span class="line">   }</span><br><span class="line">      }</span><br><span class="line">      //自定义线程类，实现Runnable接口</span><br><span class="line">      //这并不是一个线程类，是一个可运行的类，它还不是一个线程。</span><br><span class="line">      class MyRunnable implements Runnable{</span><br><span class="line">      @Override</span><br><span class="line">      public void run() {</span><br><span class="line">       for (int i = 0; i &lt; 50; i++) {</span><br><span class="line">           System.out.println(Thread.currentThread().getName() + " - " + i);</span><br><span class="line">       }</span><br><span class="line">   }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></code></pre><h6 id="1-7-多线程的实现方式（三）"><a href="#1-7-多线程的实现方式（三）" class="headerlink" title="1.7 - 多线程的实现方式（三）"></a>1.7 - 多线程的实现方式（三）</h6><p>实现Callable接口（ java.util.concurrent.FutureTask; /JUC包下的，属于java的并发包，老JDK中没有这个包。新特性。）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   1、自定义一个MyCallable类来实现Callable接口</span><br><span class="line"></span><br><span class="line">   2、在MyCallable类中重写call()方法</span><br><span class="line"></span><br><span class="line">   3、创建FutureTask，Thread对象，并把MyCallable对象作为FutureTask类构造方法的参数传递进去，把FutureTask对象传递给Thread对象。</span><br><span class="line"></span><br><span class="line">   4、启动线程</span><br><span class="line"></span><br><span class="line">           这种方式的优点：可以获取到线程的执行结果。</span><br><span class="line">       </span><br><span class="line">           这种方式的缺点：效率比较低，在获取t线程执行结果的时候，当前线程受阻塞，效率较低。</span><br><span class="line"></span><br><span class="line">   import java.util.concurrent.Callable;</span><br><span class="line">   import java.util.concurrent.FutureTask;</span><br><span class="line">   /**</span><br><span class="line">    * @author Mr.乐</span><br><span class="line">    * @Description  线程实现的第三种方式</span><br><span class="line">    */</span><br><span class="line">    public class Demo04 {</span><br><span class="line">       public static void main(String[] args) throws Exception {</span><br><span class="line"></span><br><span class="line">           // 第一步：创建一个“未来任务类”对象。</span><br><span class="line">           // 参数非常重要，需要给一个Callable接口实现类对象。</span><br><span class="line">           FutureTask task = new FutureTask(new Callable() {</span><br><span class="line">               @Override</span><br><span class="line">               public Object call() throws Exception { // call()方法就相当于run方法。只不过这个有返回值</span><br><span class="line">                   // 线程执行一个任务，执行之后可能会有一个执行结果</span><br><span class="line">                   // 模拟执行</span><br><span class="line">                   System.out.println("call method begin");</span><br><span class="line">                   Thread.sleep(1000 * 10);</span><br><span class="line">                   System.out.println("call method end!");</span><br><span class="line">                   int a = 100;</span><br><span class="line">                   int b = 200;</span><br><span class="line">                   return a + b; //自动装箱(300结果变成Integer)</span><br><span class="line">               }</span><br><span class="line">           });</span><br><span class="line">         </span><br><span class="line">           // 创建线程对象</span><br><span class="line">           Thread t = new Thread(task);</span><br><span class="line">         </span><br><span class="line">           // 启动线程</span><br><span class="line">           t.start();</span><br><span class="line">         </span><br><span class="line">           // 这里是main方法，这是在主线程中。</span><br><span class="line">           // 在主线程中，怎么获取t线程的返回结果？</span><br><span class="line">           // get()方法的执行会导致“当前线程阻塞”</span><br><span class="line">           Object obj = task.get();</span><br><span class="line">           System.out.println("线程执行结果:" + obj);</span><br><span class="line">           // main方法这里的程序要想执行必须等待get()方法的结束</span><br><span class="line">           // 而get()方法可能需要很久。因为get()方法是为了拿另一个线程的执行结果</span><br><span class="line">           // 另一个线程执行是需要时间的。</span><br><span class="line">           System.out.println("hello world!");</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    1.8 -线程控制</span><br><span class="line">    方法名说明</span><br><span class="line">    void yield()使当前线程让步，重新回到争夺CPU执行权的队列中</span><br><span class="line">    static void sleep(long ms)使当前正在执行的线程停留指定的毫秒数</span><br><span class="line">    void join()等死（等待当前线程销毁后，再继续执行其它的线程）</span><br><span class="line">    void interrupt()终止线程睡眠</span><br><span class="line">    1.8.1 -sleep()方法 (谁执行谁就是当前线程)</span><br><span class="line">    /**</span><br><span class="line">    * @author Mr.乐</span><br><span class="line">    * @Description 线程睡眠</span><br><span class="line">    */</span><br><span class="line">       public class DemoSleep {</span><br><span class="line">       public static void main(String[] args) {</span><br><span class="line">           //        创建线程</span><br><span class="line">           MyThread1 t01 = new MyThread1("黄固");</span><br><span class="line">           MyThread1 t02 = new MyThread1("欧阳锋");</span><br><span class="line">           MyThread1 t03 = new MyThread1("段智兴");</span><br><span class="line">           MyThread1 t04 = new MyThread1("洪七公");</span><br><span class="line">    </span><br><span class="line">           //开启线程</span><br><span class="line">           t01.start();</span><br><span class="line">           t02.start();</span><br><span class="line">           t03.start();</span><br><span class="line">           t04.start();</span><br><span class="line">       }</span><br><span class="line">       }</span><br><span class="line">       class MyThread1 extends Thread{</span><br><span class="line">       public MyThread1() {</span><br><span class="line">       }</span><br><span class="line">    </span><br><span class="line">       public MyThread1(String name) {</span><br><span class="line">           super(name);</span><br><span class="line">       }</span><br><span class="line">    </span><br><span class="line">       @Override</span><br><span class="line">       // 重点：run()当中的异常不能throws，只能try catch</span><br><span class="line">       // 因为run()方法在父类中没有抛出任何异常，子类不能比父类抛出更多的异常。</span><br><span class="line">       public void run() {</span><br><span class="line">           for (int i = 1; i &lt; 50; i++) {</span><br><span class="line">               System.out.println(this.getName() + "正在打出第 - " + i + "招");</span><br><span class="line">    </span><br><span class="line">               try {</span><br><span class="line">                   Thread.sleep(500);//让当前正在执行的线程睡眠指定毫秒数</span><br><span class="line">               } catch (InterruptedException e) {</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       }</span><br><span class="line">           注意：run（）方法中的异常只能try catch，因为父类没有抛出异常，子类不能抛出比父类更多的异常。 </span><br><span class="line"></span><br><span class="line">   1.8.2 -interrupt()方法和stop()方法</span><br><span class="line">   /**</span><br><span class="line">    * @author Mr.乐</span><br><span class="line">    * @Description  终止线程</span><br><span class="line">    */</span><br><span class="line">       public class DemoInterrupt {</span><br><span class="line">       public static void main(String[] args) {</span><br><span class="line">           Thread t = new Thread(new MyRunnable2());</span><br><span class="line">           t.setName("t");</span><br><span class="line">           t.start();</span><br><span class="line">           try {</span><br><span class="line">               Thread.sleep(1000 * 5);</span><br><span class="line">           } catch (InterruptedException e) {</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           }</span><br><span class="line">           // 终断t线程的睡眠（这种终断睡眠的方式依靠了java的异常处理机制。）</span><br><span class="line">           t.interrupt();</span><br><span class="line">       //        t.stop(); //强行终止线程</span><br><span class="line">           //缺点:容易损坏数据  线程没有保存的数据容易丢失</span><br><span class="line">       }</span><br><span class="line">       }</span><br><span class="line">       class MyRunnable2 implements Runnable {</span><br><span class="line">       @Override</span><br><span class="line">       public void run() {</span><br><span class="line">           System.out.println(Thread.currentThread().getName() + "---&gt; begin");</span><br><span class="line">           try {</span><br><span class="line">               // 睡眠1年</span><br><span class="line">               Thread.sleep(1000 * 60 * 60 * 24 * 365);</span><br><span class="line">           } catch (InterruptedException e) {</span><br><span class="line">       //            e.printStackTrace();</span><br><span class="line">           }</span><br><span class="line">           //1年之后才会执行这里</span><br><span class="line">           System.out.println(Thread.currentThread().getName() + "---&gt; end");</span><br><span class="line"></span><br><span class="line">       }</span><br><span class="line">       }</span><br><span class="line">        1.8.3 -合理的终止线程</span><br><span class="line">           做一个boolean类型的标记</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * @author Mr.乐</span><br><span class="line">    * @Description</span><br><span class="line">    */</span><br><span class="line">    public class DemoSleep02 {</span><br><span class="line">       public static void main(String[] args) {</span><br><span class="line">           MyRunable4 r = new MyRunable4();</span><br><span class="line">           Thread t = new Thread(r);</span><br><span class="line">           t.setName("t");</span><br><span class="line">           t.start();</span><br><span class="line"></span><br><span class="line">           // 模拟5秒</span><br><span class="line">           try {</span><br><span class="line">               Thread.sleep(5000);</span><br><span class="line">           } catch (InterruptedException e) {</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           }</span><br><span class="line">           // 终止线程</span><br><span class="line">           // 你想要什么时候终止t的执行，那么你把标记修改为false，就结束了。</span><br><span class="line">           r.run = false;</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    class MyRunable4 implements Runnable {</span><br><span class="line">    </span><br><span class="line">       // 打一个布尔标记</span><br><span class="line">       boolean run = true;</span><br><span class="line">    </span><br><span class="line">       @Override</span><br><span class="line">       public void run() {</span><br><span class="line">           for (int i = 0; i &lt; 10; i++){</span><br><span class="line">               if(run){</span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + "---&gt;" + i);</span><br><span class="line">                   try {</span><br><span class="line">                       Thread.sleep(1000);</span><br><span class="line">                   } catch (InterruptedException e) {</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   }</span><br><span class="line">               }else{</span><br><span class="line">                   // return就结束了，你在结束之前还有什么没保存的。</span><br><span class="line">                   // 在这里可以保存呀。</span><br><span class="line">                   //save....</span><br><span class="line">                   //终止当前线程</span><br><span class="line">                   return;</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    1.8.4 - yield()</span><br><span class="line">    暂停当前正在执行的线程对象，并执行其他线程</span><br><span class="line">    yield()方法不是阻塞方法。让当前线程让位，让给其它线程使用。</span><br><span class="line">    yield()方法的执行会让当前线程从“运行状态”回到“就绪状态”。</span><br><span class="line">    注意：在回到就绪之后，有可能还会再次抢到。</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * @author Mr.乐</span><br><span class="line">    * @Description 线程让位</span><br><span class="line">    */</span><br><span class="line">    public class DemoYield {</span><br><span class="line">       public static void main(String[] args) {</span><br><span class="line">           //创建线程</span><br><span class="line">           MyThread5 t01 = new MyThread5("线程01");</span><br><span class="line">           MyThread5 t02 = new MyThread5("线程02");</span><br><span class="line">           MyThread5 t03 = new MyThread5("线程03");</span><br><span class="line"></span><br><span class="line">           //开启线程</span><br><span class="line">           t01.start();</span><br><span class="line">           t02.start();</span><br><span class="line">           t03.start();</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    class MyThread5 extends Thread{</span><br><span class="line">       public MyThread5() {</span><br><span class="line">       }</span><br><span class="line">    </span><br><span class="line">       public MyThread5(String name) {</span><br><span class="line">           super(name);</span><br><span class="line">       }</span><br><span class="line">    </span><br><span class="line">       @Override</span><br><span class="line">       public void run() {</span><br><span class="line">           for (int i = 0; i &lt; 50; i++) {</span><br><span class="line">               if(30 == i){</span><br><span class="line">                   Thread.yield();//当循i环到30时，让线程让步</span><br><span class="line">                   //1、回到抢占队列中，又争夺到了执行权</span><br><span class="line">                   //2、回到抢占队列中，没有争夺到执行权</span><br><span class="line">               }</span><br><span class="line">               System.out.println(this.getName() + ":" + i);</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    1.8.5 -join()</span><br><span class="line">   1.9 - 线程的调度</span><br><span class="line">   线程调度模型</span><br><span class="line"></span><br><span class="line">   均分式调度模型：所有的线程轮流使用CPU的使用权，平均分配给每一个线程占用CPU的时间。</span><br><span class="line"></span><br><span class="line">   抢占式调度模型：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么就会随机选择一个线程来执行，优先级高的占用CPU时间相对来说会高一点点。</span><br><span class="line"></span><br><span class="line">   Java中JVM使用的就是抢占式调度模型</span><br><span class="line"></span><br><span class="line">   getPriority():获取线程优先级</span><br><span class="line"></span><br><span class="line">   setPriority：设置线程优先级</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * @author Mr.乐</span><br><span class="line">    * @Description  线程的调度</span><br><span class="line">    */</span><br><span class="line">    public class Demo07 {</span><br><span class="line">       public static void main(String[] args) {</span><br><span class="line">           //创建线程</span><br><span class="line">           MyThread t01 = new MyThread("线程01");</span><br><span class="line">           MyThread t02 = new MyThread("线程02");</span><br><span class="line">           MyThread t03 = new MyThread("线程03");</span><br><span class="line">           //获取线程优先级，默认是5</span><br><span class="line">    //        System.out.println(t01.getPriority());</span><br><span class="line">    //        System.out.println(t02.getPriority());</span><br><span class="line">    //        System.out.println(t03.getPriority());</span><br><span class="line">           //设置线程优先级</span><br><span class="line">           t01.setPriority(Thread.MIN_PRIORITY); //低  - 理论上来讲，最后完成</span><br><span class="line">           t02.setPriority(Thread.NORM_PRIORITY); //中</span><br><span class="line">           t03.setPriority(Thread.MAX_PRIORITY); //高  - 理论上来讲，最先完成</span><br><span class="line">           //开启线程</span><br><span class="line">           t01.start();</span><br><span class="line">           t02.start();</span><br><span class="line">           t03.start();</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    2 - 线程的安全</span><br><span class="line">    2.1 - 数据安全问题</span><br><span class="line">    是否具备多线程的环境</span><br><span class="line"></span><br><span class="line">   是否有共享数据</span><br><span class="line"></span><br><span class="line">   是否有多条语句操作共享数据</span><br><span class="line"></span><br><span class="line">   例如：我和小明同时取一个账户的钱，我取钱后数据还没返回给服务器，小明又取了，这个时候小明的余额还是原来的。</span><br><span class="line"></span><br><span class="line">   如何解决？线程排队执行（不能并发），线程同步机制。</span><br><span class="line"></span><br><span class="line">   2.1.1 -变量对线程安全的影响</span><br><span class="line">    实例变量：在堆中。</span><br><span class="line"></span><br><span class="line">   静态变量：在方法区。</span><br><span class="line"></span><br><span class="line">   局部变量：在栈中。</span><br><span class="line"></span><br><span class="line">       以上三大变量中：</span><br><span class="line">           局部变量永远都不会存在线程安全问题。</span><br><span class="line">           因为局部变量不共享。（一个线程一个栈。）</span><br><span class="line">           局部变量在栈中。所以局部变量永远都不会共享。</span><br><span class="line">       </span><br><span class="line">        实例变量在堆中，堆只有1个。</span><br><span class="line">       静态变量在方法区中，方法区只有1个。</span><br><span class="line">       堆和方法区都是多线程共享的，所以可能存在线程安全问题。</span><br><span class="line">       </span><br><span class="line">       局部变量+常量：不会有线程安全问题。</span><br><span class="line">       成员变量：可能会有线程安全问题。</span><br><span class="line">    </span><br><span class="line">    2.1.2 -模拟线程安全问题</span><br><span class="line">   public class Test {</span><br><span class="line">       public static void main(String[] args) {</span><br><span class="line">           // 创建账户对象（只创建1个）</span><br><span class="line">          Account act = new Account("act-001", 10000);</span><br><span class="line">           // 创建两个线程</span><br><span class="line">           Thread t1 = new AccountThread(act);</span><br><span class="line">           Thread t2 = new AccountThread(act);</span><br><span class="line">           // 设置name</span><br><span class="line">           t1.setName("t1");</span><br><span class="line">           t2.setName("t2");</span><br><span class="line">           // 启动线程取款</span><br><span class="line">           t1.start();</span><br><span class="line">           t2.start();</span><br><span class="line">           //t1对act-001取款5000.0成功，余额5000.0</span><br><span class="line">           //t2对act-001取款5000.0成功，余额5000.0</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">   public class AccountThread extends Thread {</span><br><span class="line"></span><br><span class="line">       // 两个线程必须共享同一个账户对象。</span><br><span class="line">       private Account act;</span><br><span class="line">        </span><br><span class="line">       // 通过构造方法传递过来账户对象</span><br><span class="line">       public AccountThread(Account act) {</span><br><span class="line">           this.act = act;</span><br><span class="line">       }</span><br><span class="line">        </span><br><span class="line">       public void run(){</span><br><span class="line">           // run方法的执行表示取款操作。</span><br><span class="line">           // 假设取款5000</span><br><span class="line">           double money = 5000;</span><br><span class="line">           // 取款</span><br><span class="line">           // 多线程并发执行这个方法。</span><br><span class="line">           act.withdraw(money);</span><br><span class="line">        </span><br><span class="line">           System.out.println(Thread.currentThread().getName() + "对"+act.getActno()+"取款"+money+"成功，余额" + act.getBalance());</span><br><span class="line">       }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * @author Mr.乐</span><br><span class="line">    * @Description</span><br><span class="line">    */</span><br><span class="line">    public class Account {</span><br><span class="line">           // 账号</span><br><span class="line">           private String actno;</span><br><span class="line">           // 余额</span><br><span class="line">           private double balance;</span><br><span class="line"></span><br><span class="line">       public Account() {</span><br><span class="line">           }</span><br><span class="line">    </span><br><span class="line">       public Account(String actno, double balance) {</span><br><span class="line">               this.actno = actno;</span><br><span class="line">               this.balance = balance;</span><br><span class="line">           }</span><br><span class="line">    </span><br><span class="line">           public String getActno() {</span><br><span class="line">               return actno;</span><br><span class="line">           }</span><br><span class="line">         </span><br><span class="line">           public void setActno(String actno) {</span><br><span class="line">               this.actno = actno;</span><br><span class="line">           }</span><br><span class="line">         </span><br><span class="line">           public double getBalance() {</span><br><span class="line">               return balance;</span><br><span class="line">           }</span><br><span class="line">         </span><br><span class="line">           public void setBalance(double balance) {</span><br><span class="line">               this.balance = balance;</span><br><span class="line">           }</span><br><span class="line">       //取款的方法</span><br><span class="line">       public void withdraw(double money){</span><br><span class="line">           // t1和t2并发这个方法。。。。（t1和t2是两个栈。两个栈操作堆中同一个对象。）</span><br><span class="line">           // 取款之前的余额</span><br><span class="line">           double before = this.getBalance(); // 10000</span><br><span class="line">           // 取款之后的余额</span><br><span class="line">           double after = before - money;</span><br><span class="line">           // 在这里模拟一下网络延迟，100%会出现问题</span><br><span class="line">           try {</span><br><span class="line">               Thread.sleep(1000);</span><br><span class="line">           } catch (InterruptedException e) {</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           }</span><br><span class="line">    </span><br><span class="line">           // 更新余额</span><br><span class="line">           // 思考：t1执行到这里了，但还没有来得及执行这行代码，t2线程进来withdraw方法了。此时一定出问题。</span><br><span class="line">           this.setBalance(after);</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    2.2 - 线程同步的利弊</span><br><span class="line">    好处：解决了线程同步的数据安全问题</span><br><span class="line"></span><br><span class="line">   弊端：当线程很多的时候，每个线程都会去判断同步上面的这个锁，很耗费资源，降低效率</span><br><span class="line"></span><br><span class="line">   2.3 -编程模型 </span><br><span class="line">   异步编程模型：</span><br><span class="line">               线程t1和线程t2，各自执行各自的，t1不管t2，t2不管t1，</span><br><span class="line">               谁也不需要等谁，这种编程模型叫做：异步编程模型。</span><br><span class="line">               其实就是：多线程并发（效率较高。）</span><br><span class="line"></span><br><span class="line">   同步编程模型：</span><br><span class="line">               线程t1和线程t2，在线程t1执行的时候，必须等待t2线程执行</span><br><span class="line">               结束，或者说在t2线程执行的时候，必须等待t1线程执行结束，</span><br><span class="line">               两个线程之间发生了等待关系，这就是同步编程模型。</span><br><span class="line">               效率较低。线程排队执行。</span><br><span class="line"></span><br><span class="line">   2.4 -线程同步</span><br><span class="line">   2.4.1 -线程同步方式</span><br><span class="line">           同步语句块：synchronized(this){方法体}  （synchronized括号后的数据必须是多线程共享的数据，才能达到多线程排队）</span><br><span class="line"></span><br><span class="line">   //        以下代码的执行原理？</span><br><span class="line">   //        1、假设t1和t2线程并发，开始执行以下代码的时候，肯定有一个先一个后。</span><br><span class="line">   //        2、假设t1先执行了，遇到了synchronized，这个时候自动找“后面共享对象”的对象锁，</span><br><span class="line">   //        找到之后，并占有这把锁，然后执行同步代码块中的程序，在程序执行过程中一直都是</span><br><span class="line">   //        占有这把锁的。直到同步代码块代码结束，这把锁才会释放。</span><br><span class="line">   //        3、假设t1已经占有这把锁，此时t2也遇到synchronized关键字，也会去占有后面</span><br><span class="line">   //        共享对象的这把锁，结果这把锁被t1占有，t2只能在同步代码块外面等待t1的结束，</span><br><span class="line">   //        直到t1把同步代码块执行结束了，t1会归还这把锁，此时t2终于等到这把锁，然后</span><br><span class="line">   //        t2占有这把锁之后，进入同步代码块执行程序。</span><br><span class="line">   //</span><br><span class="line">   //        这样就达到了线程排队执行。</span><br><span class="line">   //        这里需要注意的是：这个共享对象一定要选好了。这个共享对象一定是你需要排队</span><br><span class="line">   //        执行的这些线程对象所共享的。</span><br><span class="line">           synchronized (this){</span><br><span class="line">               double before = this.getBalance();</span><br><span class="line">               double after = before - money;</span><br><span class="line">               try {</span><br><span class="line">                   Thread.sleep(1000);</span><br><span class="line">               } catch (InterruptedException e) {</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               }</span><br><span class="line">               this.setBalance(after);</span><br><span class="line">           }</span><br><span class="line">           普通同步方法：修饰符 synchronized 返回值类型 方法名（形参列表）{方法体}</span><br><span class="line"></span><br><span class="line">           synchronized出现在实例方法上，一定锁的是this（此方法）。不能是其他的对象了。 所以这种方式不灵活。</span><br><span class="line">       </span><br><span class="line">           另外还有一个缺点：synchronized出现在实例方法上， 表示整个方法体都需要同步，可能会无故扩大同步的 范围，导致程序的执行效率降低。所以这种方式不常用。</span><br><span class="line">       </span><br><span class="line">       public synchronized void withdraw(double money){</span><br><span class="line">           double before = this.getBalance(); // 10000</span><br><span class="line">           // 取款之后的余额</span><br><span class="line">           double after = before - money;</span><br><span class="line">           try {</span><br><span class="line">               Thread.sleep(1000);</span><br><span class="line">           } catch (InterruptedException e) {</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           }</span><br><span class="line">        </span><br><span class="line">           // 更新余额</span><br><span class="line">           this.setBalance(after);</span><br><span class="line">           静态同步方法：修饰符 synchronized static 返回值类型 方法名（形参列表）{方法体}</span><br><span class="line">    </span><br><span class="line">    （静态方法中不能使用this）表示找类锁。类锁永远只有1把。</span><br><span class="line">    </span><br><span class="line">    2.5 -如何解决线程安全问题</span><br><span class="line">       是一上来就选择线程同步吗？synchronized</span><br><span class="line">           不是，synchronized会让程序的执行效率降低，用户体验不好。</span><br><span class="line">           系统的用户吞吐量降低。用户体验差。在不得已的情况下再选择</span><br><span class="line">           线程同步机制。</span><br><span class="line">    </span><br><span class="line">       第一种方案：尽量使用局部变量代替“实例变量和静态变量”。  </span><br><span class="line">       </span><br><span class="line">       第二种方案：如果必须是实例变量，那么可以考虑创建多个对象，这样</span><br><span class="line">       实例变量的内存就不共享了。（一个线程对应1个对象，100个线程对应100个对象，</span><br><span class="line">       对象不共享，就没有数据安全问题了。）</span><br><span class="line">       </span><br><span class="line">       第三种方案：如果不能使用局部变量，对象也不能创建多个，这个时候</span><br><span class="line">       就只能选择synchronized了。线程同步机制。</span><br><span class="line"></span><br><span class="line">   2.6 -Lock</span><br><span class="line">           应用场景不同，不一定要在同一个方法中进行解锁，如果在当前的方法体内部没有满足解锁需求时，可以将lock引用传递到下一个方法中，当满足解锁需求时进行解锁操作，方法比较灵活。</span><br><span class="line"></span><br><span class="line">      private Lock lock = new ReentrantLock();//定义Lock类型的锁</span><br><span class="line">      public  void withdraw(double money){</span><br><span class="line">           // t1和t2并发这个方法。。。。（t1和t2是两个栈。两个栈操作堆中同一个对象。）</span><br><span class="line">           // 取款之前的余额</span><br><span class="line">           lock.lock();//上锁</span><br><span class="line">           double before = this.getBalance(); // 10000</span><br><span class="line">           // 取款之后的余额</span><br><span class="line">           double after = before - money;</span><br><span class="line">           // 在这里模拟一下网络延迟，100%会出现问题</span><br><span class="line">           try {</span><br><span class="line">               Thread.sleep(1000);</span><br><span class="line">           } catch (InterruptedException e) {</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           }</span><br><span class="line">    </span><br><span class="line">           // 更新余额</span><br><span class="line">           // 思考：t1执行到这里了，但还没有来得及执行这行代码，t2线程进来withdraw方法了。此时一定出问题。</span><br><span class="line">           this.setBalance(after);</span><br><span class="line">           lock.unlock();//解锁</span><br><span class="line">       }</span><br><span class="line">    2.7 -死锁</span><br><span class="line">   形成原因</span><br><span class="line"></span><br><span class="line">   当两个线程或者多个线程互相锁定的情况就叫死锁</span><br><span class="line"></span><br><span class="line">   避免死锁的原则</span><br><span class="line"></span><br><span class="line">   顺序上锁，反向解锁，不要回头</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * @author Mr.乐</span><br><span class="line">    * @Description 死锁</span><br><span class="line">    */</span><br><span class="line">    public class DeadLock {</span><br><span class="line">       public static void main(String[] args) {</span><br><span class="line">           Object o1 = new Object();</span><br><span class="line">           Object o2 = new Object();</span><br><span class="line"></span><br><span class="line">           // t1和t2两个线程共享o1,o2</span><br><span class="line">           Thread t1 = new MyThread1(o1,o2);</span><br><span class="line">           Thread t2 = new MyThread2(o1,o2);</span><br><span class="line">         </span><br><span class="line">           t1.start();</span><br><span class="line">           t2.start();</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">   class MyThread1 extends Thread{</span><br><span class="line">       Object o1;</span><br><span class="line">       Object o2;</span><br><span class="line">       public MyThread1(Object o1,Object o2){</span><br><span class="line">           this.o1 = o1;</span><br><span class="line">           this.o2 = o2;</span><br><span class="line">       }</span><br><span class="line">       public void run(){</span><br><span class="line">           synchronized (o1){</span><br><span class="line">               try {</span><br><span class="line">                   Thread.sleep(1000);</span><br><span class="line">               } catch (InterruptedException e) {</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               }</span><br><span class="line">               synchronized (o2){</span><br><span class="line"></span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   class MyThread2 extends Thread {</span><br><span class="line">       Object o1;</span><br><span class="line">       Object o2;</span><br><span class="line">       public MyThread2(Object o1,Object o2){</span><br><span class="line">           this.o1 = o1;</span><br><span class="line">           this.o2 = o2;</span><br><span class="line">       }</span><br><span class="line">       public void run(){</span><br><span class="line">           synchronized (o2){</span><br><span class="line">               try {</span><br><span class="line">                   Thread.sleep(1000);</span><br><span class="line">               } catch (InterruptedException e) {</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               }</span><br><span class="line">               synchronized (o1){</span><br><span class="line"></span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">   }</span><br><span class="line">    2.8 -守护线程</span><br><span class="line">   java语言中线程分为两大类：</span><br><span class="line">               一类是：用户线程</span><br><span class="line">               一类是：守护线程（后台线程）</span><br><span class="line">               其中具有代表性的就是：垃圾回收线程（守护线程）。</span><br><span class="line"></span><br><span class="line">           守护线程的特点：</span><br><span class="line">               一般守护线程是一个死循环，所有的用户线程只要结束，</span><br><span class="line">               守护线程自动结束。</span><br><span class="line">           </span><br><span class="line">           注意：主线程main方法是一个用户线程。</span><br><span class="line">       </span><br><span class="line">           守护线程用在什么地方呢？</span><br><span class="line">               每天00:00的时候系统数据自动备份。</span><br><span class="line">               这个需要使用到定时器，并且我们可以将定时器设置为守护线程。</span><br><span class="line">               一直在那里看着，每到00:00的时候就备份一次。所有的用户线程</span><br><span class="line">               如果结束了，守护线程自动退出，没有必要进行数据备份了。</span><br><span class="line"></span><br><span class="line">   public class Demo09 {</span><br><span class="line">       public static void main(String[] args) {</span><br><span class="line">           Thread t = new BakDataThread();</span><br><span class="line">           t.setName("备份数据的线程");</span><br><span class="line"></span><br><span class="line">           // 启动线程之前，将线程设置为守护线程</span><br><span class="line">           t.setDaemon(true);</span><br><span class="line">           t.start();</span><br><span class="line">           // 主线程：主线程是用户线程</span><br><span class="line">           for(int i = 0; i &lt; 10; i++){</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + "---&gt;" + i);</span><br><span class="line">               try {</span><br><span class="line">                   Thread.sleep(1000);</span><br><span class="line">               } catch (InterruptedException e) {</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   class BakDataThread extends Thread {</span><br><span class="line">       public void run(){</span><br><span class="line">           int i = 0;</span><br><span class="line">           // 即使是死循环，但由于该线程是守护者，当用户线程结束，守护线程自动终止。</span><br><span class="line">           while(true){</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + "---&gt;" + (++i));</span><br><span class="line">               try {</span><br><span class="line">                   Thread.sleep(1000);</span><br><span class="line">               } catch (InterruptedException e) {</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">   }</span><br><span class="line">   3 -定时器</span><br><span class="line">   定时器的作用：</span><br><span class="line">               间隔特定的时间，执行特定的程序。</span><br><span class="line"></span><br><span class="line">   在java的类库中已经写好了一个定时器：java.util.Timer，可以直接拿来用。</span><br><span class="line">               不过，这种方式在目前的开发中也很少用，因为现在有很多高级框架都是支持</span><br><span class="line">                定时任务的。 </span><br><span class="line"></span><br><span class="line">   import java.util.Timer;</span><br><span class="line">   import java.util.TimerTask;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * @author Mr.乐</span><br><span class="line">    * @Description 定时类</span><br><span class="line">    */</span><br><span class="line">    public class DemoTimer {</span><br><span class="line">       public static void main(String[] args) {</span><br><span class="line">           Timer timer = new Timer();//创建Timer定时器类的对象</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">       //匿名内部类</span><br><span class="line">       timer.schedule(new TimerTask() {</span><br><span class="line">           @Override</span><br><span class="line">           public void run() {</span><br><span class="line">               System.out.println("我被执行了！~");</span><br><span class="line">               System.gc();//告诉JVM运行完毕，可以把我回收</span><br><span class="line">           }</span><br><span class="line">       },5000);</span><br><span class="line">   }</span><br><span class="line">}</span><br><span class="line">3.1 -线程与定时器执行轨迹不同</span><br><span class="line">线程与定时器之间互不抢占CPU时间片</span><br><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">import java.util.Timer;</span><br><span class="line">import java.util.TimerTask;</span><br><span class="line">   </span><br><span class="line">   /**</span><br><span class="line">   </span><br><span class="line">    * @author Mr.乐</span><br><span class="line">   </span><br><span class="line">    * @Description 线程与定时器的执行轨迹不同</span><br><span class="line">      */</span><br><span class="line">      public class DemoTimer {</span><br><span class="line">      public static void main(String[] args) {</span><br><span class="line">          new Thread(new Runnable() {</span><br><span class="line">              @Override</span><br><span class="line">              public void run() {</span><br><span class="line">                  for (int i = 0; i &lt; 20; i++) {</span><br><span class="line">                      System.out.println(Thread.currentThread().getName() + "&lt;---&gt;" + i);</span><br><span class="line">                   try {</span><br><span class="line">                          Thread.sleep(1000);</span><br><span class="line">                      } catch (InterruptedException e) {</span><br><span class="line">                          e.printStackTrace();</span><br><span class="line">                      }</span><br><span class="line">                  }</span><br><span class="line">              }</span><br><span class="line">          }).start();</span><br><span class="line">   </span><br><span class="line">          //定时器实现</span><br><span class="line">          new Timer().schedule(new TimerTask() {</span><br><span class="line">              @Override</span><br><span class="line">              public void run() {</span><br><span class="line">                  for (int i = 0; i &lt; 10; i++) {</span><br><span class="line">                      System.out.println(Thread.currentThread().getName() + "---" + i);</span><br><span class="line">                      try {</span><br><span class="line">                          Thread.sleep(1000);</span><br><span class="line">                   } catch (InterruptedException e) {</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line">               System.gc();//将编程垃圾的定时器进行回收</span><br><span class="line">           }</span><br><span class="line">       },5000);</span><br><span class="line"></span><br><span class="line">   }</span><br><span class="line">   }</span><br><span class="line">```</span><br></pre></td></tr></tbody></table></figure><p>原文链接：<a href="https://blog.csdn.net/zdl66/article/details/126297036">https://blog.csdn.net/zdl66/article/details/126297036</a></p><h5 id="1-7一些常用方法"><a href="#1-7一些常用方法" class="headerlink" title="1.7一些常用方法"></a>1.7一些常用方法</h5><h6 id="start"><a href="#start" class="headerlink" title="start()"></a><code>start()</code></h6><p>start() 函数 API 定义：</p><blockquote><p>使该线程开始执行，Java 虚拟机调用该线程的 run 方法。结果是两个线程并发地运行；当前线程（从调用返回给 start 方法）和另一个线程（执行其 run 方法）。多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。</p></blockquote><p>start() 函数启动线程执行以下任务：</p><blockquote><ul><li>它统计了一个新线程</li><li>线程从 New State 移动到 Runnable 状态。</li><li>当线程有机会执行时，它的目标 <code>run()</code> 方法将运行。</li><li>start() 方法不能多次重复调用，否则抛出 java.lang.IllegalStateException 异常；</li></ul></blockquote><p>小结：</p><p><code>start()</code> 函数用来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码；通过调用 Thread 类的 <code>start()</code> 方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 然后通过此 Thread 类调用方法 <code>run()</code> 来完成其运行操作的， 这里方法 <code>run()</code> 称为线程体，它包含了要执行的这个线程的内容。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。</p><h6 id="run"><a href="#run" class="headerlink" title="run()"></a><code>run()</code></h6><p>run() 函数 API 定义：</p><blockquote><p>如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。Thread 的子类应该重写该方法。</p></blockquote><p>run() 函数启动：</p><blockquote><p>线程类的 <code>run()</code> 方法是 Runnable 接口的一个抽象函数，由 java 虚拟机直接调用的，不会创建的新线程。所以可以被多次调用，因为它只是一个抽象函数。</p></blockquote><p>小结：</p><blockquote><p>run() 函数只是类的一个普通函数而已，如果直接调用 run 方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待 run 方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。<br>作者：不愿意透露姓名的轩叔叔<br>链接：<a href="https://www.jianshu.com/p/76933cd66c2f">https://www.jianshu.com/p/76933cd66c2f</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p><strong>总结：调用 start 方法方可启动线程，而 run 方法只是 Thread 的一个普通方法调用，还是在主线程里执行。</strong></p><p><strong>Thread类中run()和start()方法的区别如下：</strong><br><strong>run()方法:在本线程内调用该Runnable对象的run()方法，可以重复多次调用；</strong><br><strong>start()方法:启动一个线程，调用该Runnable对象的run()方法，不能多次启动一个线程；</strong></p><h6 id="sleep-的作用"><a href="#sleep-的作用" class="headerlink" title="sleep() 的作用"></a><strong><code>sleep() 的作用</code></strong></h6><p>是让当前线程休眠，即当前线程会从“运行状态”进入到“休眠(阻塞)状态”。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度执行。</p><p>（1）wait：线程不再进行活动，不再参与调度，进入WAITING状态，因此不会浪费CPU资源，也不会去竞争锁资源。它需要等待其它线程执行一个特殊动作，也就是“notify（通知）”在这个对象上等待的线程从WAITING状态中释放出来，重新进入调度队列（ready queue）中。</p><p>（2）notify：则选取所通知对象的 wait set 中的一个线程释放；<br>（3）notifyAll：则释放所通知对象的 wait set 上的全部线程。</p><p>原文链接：<a href="https://blog.csdn.net/qq_33479841/article/details/125596223">https://blog.csdn.net/qq_33479841/article/details/125596223</a></p><h6 id="join"><a href="#join" class="headerlink" title="join"></a><code>join</code></h6><p>先将当前线程挂起，待其他线程结束后在执行当前线程的代码；</p><h4 id="2、锁"><a href="#2、锁" class="headerlink" title="2、锁"></a>2、锁</h4><p>在java中，加锁需要使用synchronized关键字，锁的本质就是对于共享资源访问的一个限制，它让同一时间内只有一个线程能访问这个共享资源，以此确保<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&amp;spm=1001.2101.3001.7020">多线程</a>并发的原子性操作，因此对于synchronized而言，加锁是有作用范围的，范围就是共享资源的使用范围。</p><h5 id="2-1、实例锁"><a href="#2-1、实例锁" class="headerlink" title="2.1、实例锁"></a>2.1、实例锁</h5><p>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁，只针对于当前对象实例有效。</p><p>public class SynchronizedDemo {</p><pre><code>synchronized void method1() {    } void method2() {    synchronized (this) {     }}</code></pre><p>}<br>2.2、类锁<br>静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁，针对所有对象都互斥，因为静态方法是唯一的，所以在静态方法上加锁也是类锁。</p><p>public class SynchronizedDemo {</p><pre><code>synchronized static void method3() { } void method4() {    synchronized (SynchronizedDemo.class) {     }}</code></pre><p>}<br>2.3、代码块<br>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁，如单例模式给HashMap加锁。</p><p>public class SynchronizedDemo {<br>    Object object = new Object();</p><pre><code>void method5() {    synchronized (object) {            }}</code></pre><p>}</p><p>————————————————<br>版权声明：本文为CSDN博主「烟锁迷城」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/jiayibingdong/article/details/124388116">https://blog.csdn.net/jiayibingdong/article/details/124388116</a></p><h3 id="十一-socke编程"><a href="#十一-socke编程" class="headerlink" title="十一.socke编程"></a>十一.socke编程</h3><h4 id="1-1-网络架构模型-网络架构模型主要有OSI参考模型和TCP-IP五层模型"><a href="#1-1-网络架构模型-网络架构模型主要有OSI参考模型和TCP-IP五层模型" class="headerlink" title="1.1 网络架构模型     网络架构模型主要有OSI参考模型和TCP/IP五层模型"></a>1.1 网络<a href="https://so.csdn.net/so/search?q=%E6%9E%B6%E6%9E%84&amp;spm=1001.2101.3001.7020">架构</a>模型     网络架构模型主要有OSI参考模型和TCP/IP五层模型</h4><h5 id="1-1-1-OSI参考模型"><a href="#1-1-1-OSI参考模型" class="headerlink" title="1.1.1 OSI参考模型"></a>1.1.1 OSI参考模型</h5><p>​    OSI（Open System Interconnect），即开放式系统互联。一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互连模型。ISO为了更好的使网络应用更为普及，推出了OSI参考模型，这样所有的公司都按照统一的标准来指定自己的网络，就可以互通互联了。</p><p>​    OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）。</p><h5 id="1-1-2-TCP-IP五层模型"><a href="#1-1-2-TCP-IP五层模型" class="headerlink" title="1.1.2 TCP/IP五层模型"></a>1.1.2 TCP/IP五层模型</h5><p>​    TCP/IP五层协议（物理层、数据链路层、网络层、传输层、应用层）</p><h5 id="1-1-3-各协议层的说明"><a href="#1-1-3-各协议层的说明" class="headerlink" title="1.1.3 各协议层的说明"></a>1.1.3 各协议层的说明</h5><p>应用层</p><p>​    应用层最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，TELNET等。</p><p>传输层</p><p>​    建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。</p><p> 网络层</p><p>​    本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</p><h4 id="1-2-网络编程中的问题"><a href="#1-2-网络编程中的问题" class="headerlink" title="1.2 网络编程中的问题"></a>1.2 网络编程中的问题</h4><p>​    常见的网络编程中的问题主要是怎么定位网络上的一台主机或多台主机，另一个是定位后如何进行数据的传输。对于前者，在网络层中主要负责网络主机的定位，数据传输的路由，由IP地址可以唯一地确定Internet上的一台主机。对于后者，在传输层则提供面向应用的可靠（tcp）的或非可靠（UDP）的数据传输机制。</p><p>​    对于客户端/服务器（C/S）结构。 即通信双方一方作为服务器等待客户提出请求并予以响应。客户则在需要服务时向服务器提出申请。服务器一般作为守护进程始终运行，监听网络端口，一旦有客户请求，就会启动一个服务进程来响应该客户，同时自己继续监听服务端口，使后来的客户也能及时得到服务。</p><p>​    对于浏览器/服务器（B/S）结构。 客户则在需要服务时向服务器进行请求。服务器响应后及时返回，不需要实时监听端口。</p><h4 id="1-3-TCP协议与UDP协议"><a href="#1-3-TCP协议与UDP协议" class="headerlink" title="1.3 TCP协议与UDP协议"></a>1.3 TCP协议与UDP协议</h4><h5 id="1-3-1-TCP"><a href="#1-3-1-TCP" class="headerlink" title="1.3.1 TCP"></a>1.3.1 TCP</h5><p>​    TCP是（Tranfer Control Protocol）的简称，是一种面向连接的保证可靠传输的协议。通过TCP协议传输，得到的是一个顺序的无差错的数据流。发送方和接收方的成对的两个<a href="https://so.csdn.net/so/search?q=socket&amp;spm=1001.2101.3001.7020">socket</a>之间必须建立连接，当一个socket（通常都是server socket）等待建立连接时，另一个socket可以要求进行连接，一旦这两个socket连接起来，它们就可以进行双向数据传输，双方都可以进行发送或接收操作。</p><p>​    TCP的三次握手</p><p>​    建立起一个TCP连接需要经过“三次握手”：第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p><p>​    握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求。</p><h5 id="1-3-2-UDP"><a href="#1-3-2-UDP" class="headerlink" title="1.3.2 UDP"></a>1.3.2 UDP</h5><p>​    UDP是（User Datagram Protocol）的简称，是一种无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。</p><p>import java.io.IOException; </p><p>import java.net.DatagramPacket;</p><p> import java.net.DatagramSocket</p><h5 id="1-3-3-TCP和UDP的区别"><a href="#1-3-3-TCP和UDP的区别" class="headerlink" title="1.3.3 TCP和UDP的区别"></a>1.3.3 TCP和UDP的区别</h5><p>​    UDP：</p><p>​    1、每个数据报中都给出了完整的地址信息，因此无需要建立发送方和接收方的连接。</p><p>​    2、UDP传输数据时是有大小限制的，每个被传输的数据报必须限定在64KB之内。</p><p>​    3、UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方</p><p>​    TCP：</p><p>​    1、面向连接的协议，在socket之间进行数据传输之前必然要建立连接，所以在TCP中需要连接时间。</p><p>​    2、TCP传输数据没有大小限制，一旦连接建立起来，双方的socket就可以按统一的格式传输大的数据。</p><p>​    3、TCP是一个可靠的协议，它确保接收方完全正确地获取发送方所发送的全部数据。</p><p>​    应用：</p><p>​    1、TCP在网络通信上有极强的生命力，例如远程连接（Telnet）和文件传输（FTP）都需要不定长度的数据被可靠地传输。但是可靠的传输是要付出代价的，对数据内容正确性的检验必然占用计算机的处理时间和网络的带宽，因此TCP传输的效率不如UDP高。</p><p>​    2、UDP操作简单，而且仅需要较少的监护，因此通常用于局域网高可靠性的分散系统中client/server应用程序。例如视频会议系统，并不要求音频视频数据绝对的正确，只要保证连贯性就可以了，这种情况下显然使用UDP会更合理一些。</p><h5 id="2-socket网络编程"><a href="#2-socket网络编程" class="headerlink" title="2 socket网络编程"></a>2 socket网络编程</h5><h6 id="2-1什么是socket"><a href="#2-1什么是socket" class="headerlink" title="2.1什么是socket?"></a>2.1什么是socket?</h6><p>​    Socket的英文原义是“孔”或“插座”。在网络编程中，网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。</p><p>​    Socket套接字是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p><p>​    Socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。</p><h6 id="2-2-Socket的原理"><a href="#2-2-Socket的原理" class="headerlink" title="2.2 Socket的原理"></a>2.2 Socket的原理</h6><p>​    Socket实质上提供了进程通信的端点。进程通信之前，双方首先必须各自创建一个端点，否则是没有办法建立联系并相互通信的。正如打电话之前，双方必须各自拥有一台电话机一样。</p><p>​    套接字之间的连接过程可以分为三个步骤：服务器监听，客户端请求，连接确认。</p><p>​    1、服务器监听：是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态。</p><p>​    2、客户端请求：是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</p><p>​    3、连接确认：是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p><h5 id="3-基于java的socket网络编程实现"><a href="#3-基于java的socket网络编程实现" class="headerlink" title="3 基于java的socket网络编程实现"></a>3 基于java的socket网络编程实现</h5><p>​    Server端Listen监听某个端口是否有连接请求，Client端向Server 端发出连接请求，Server端向Client端发回Accept接受消息。这样一个连接就建立起来了。Server端和Client端都可以通过Send，Write等方法与对方通信。</p><p>​    对于一个功能齐全的Socket，都要包含以下基本结构，其工作过程包含以下四个基本的步骤：</p><p>​    <strong>1、创建Socket；</strong></p><p>​    <strong>2、 打开连接到Socket的输入/出流；</strong></p><p>​    <strong>3、按照一定的协议对Socket进行读/写操作；</strong></p><p>​    <strong>4、关闭Socket。</strong></p><h4 id="3-1-基于TCP的socket实现"><a href="#3-1-基于TCP的socket实现" class="headerlink" title="3.1 基于TCP的socket实现"></a>3.1 基于TCP的socket实现</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">SocketClient.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketClient</span> {</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">     <span class="keyword">try</span> {</span><br><span class="line">       <span class="comment">// 和服务器创建连接</span></span><br><span class="line">       <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">"localhost"</span>,<span class="number">8088</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 要发送给服务器的信息</span></span><br><span class="line">       <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">       <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(os);</span><br><span class="line">       pw.write(<span class="string">"客户端发送信息"</span>);</span><br><span class="line">       pw.flush();</span><br><span class="line">       </span><br><span class="line">       socket.shutdownOutput();</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 从服务器接收的信息</span></span><br><span class="line">       <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">       <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">       <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">while</span>((info = br.readLine())!=<span class="literal">null</span>){</span><br><span class="line">         System.out.println(<span class="string">"我是客户端，服务器返回信息："</span>+info);</span><br><span class="line">       }</span><br><span class="line">       </span><br><span class="line">       br.close();</span><br><span class="line">       is.close();</span><br><span class="line">       os.close();</span><br><span class="line">       pw.close();</span><br><span class="line">       socket.close();</span><br><span class="line">     } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line"> </span><br><span class="line">}</span><br><span class="line">SocketServer.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServer</span> {</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">     <span class="keyword">try</span> {</span><br><span class="line">       <span class="comment">// 创建服务端socket</span></span><br><span class="line">       <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8088</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 创建客户端socket</span></span><br><span class="line">       <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>();   </span><br><span class="line">       </span><br><span class="line">       <span class="comment">//循环监听等待客户端的连接</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">         <span class="comment">// 监听客户端</span></span><br><span class="line">         socket = serverSocket.accept();</span><br><span class="line">         </span><br><span class="line">         <span class="type">ServerThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerThread</span>(socket);</span><br><span class="line">         thread.start();</span><br><span class="line">         </span><br><span class="line">         InetAddress address=socket.getInetAddress();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的IP："</span>+address.getHostAddress());</span><br><span class="line">      }</span><br><span class="line">     } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">       <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line"> </span><br><span class="line">}</span><br><span class="line">ServerThread.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>{</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ServerThread</span><span class="params">(Socket socket)</span> {</span><br><span class="line">     <span class="built_in">this</span>.socket = socket;</span><br><span class="line">   }</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">     InputStream is=<span class="literal">null</span>;</span><br><span class="line">    InputStreamReader isr=<span class="literal">null</span>;</span><br><span class="line">    BufferedReader br=<span class="literal">null</span>;</span><br><span class="line">    OutputStream os=<span class="literal">null</span>;</span><br><span class="line">    PrintWriter pw=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">       is = socket.getInputStream();</span><br><span class="line">       isr = <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is);</span><br><span class="line">       br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">       </span><br><span class="line">       <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">while</span>((info=br.readLine())!=<span class="literal">null</span>){</span><br><span class="line">         System.out.println(<span class="string">"我是服务器，客户端说："</span>+info);</span><br><span class="line">       }</span><br><span class="line">       socket.shutdownInput();</span><br><span class="line">       </span><br><span class="line">       os = socket.getOutputStream();</span><br><span class="line">       pw = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(os);</span><br><span class="line">       pw.write(<span class="string">"服务器欢迎你"</span>);</span><br><span class="line">       </span><br><span class="line">       pw.flush();</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">       <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">     } <span class="keyword">finally</span>{</span><br><span class="line">       <span class="comment">//关闭资源</span></span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span>(pw!=<span class="literal">null</span>)</span><br><span class="line">          pw.close();</span><br><span class="line">        <span class="keyword">if</span>(os!=<span class="literal">null</span>)</span><br><span class="line">          os.close();</span><br><span class="line">        <span class="keyword">if</span>(br!=<span class="literal">null</span>)</span><br><span class="line">          br.close();</span><br><span class="line">        <span class="keyword">if</span>(isr!=<span class="literal">null</span>)</span><br><span class="line">          isr.close();</span><br><span class="line">        <span class="keyword">if</span>(is!=<span class="literal">null</span>)</span><br><span class="line">          is.close();</span><br><span class="line">        <span class="keyword">if</span>(socket!=<span class="literal">null</span>)</span><br><span class="line">          socket.close();</span><br><span class="line">      } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      }</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line"> </span><br><span class="line">}</span><br><span class="line">    在运行时，若先执行SocketClient会提示无法连接到服务器，因为此时没有服务在监听<span class="number">8088</span>端口。此demo是多线程实现，在先启动SocketServer后，服务器会一直监听<span class="number">8088</span>端口，再执行SocketClient就会正常输出结果。</span><br><span class="line"></span><br><span class="line">  <span class="number">3.2</span> 基于UDP的socket实现</span><br><span class="line">SocketClient.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketClient</span> {</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">     <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">// 要发送的消息</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">sendMsg</span> <span class="operator">=</span> <span class="string">"客户端发送的消息"</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 获取服务器的地址</span></span><br><span class="line">      <span class="type">InetAddress</span> <span class="variable">addr</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">"localhost"</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 创建packet包对象，封装要发送的包数据和服务器地址和端口号</span></span><br><span class="line">      <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(sendMsg.getBytes(),</span><br><span class="line">           sendMsg.getBytes().length, addr, <span class="number">8088</span>); </span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 创建Socket对象</span></span><br><span class="line">      <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 发送消息到服务器</span></span><br><span class="line">      socket.send(packet);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 关闭socket</span></span><br><span class="line">      socket.close();</span><br><span class="line">      </span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">      <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">   }</span><br><span class="line">}</span><br><span class="line">SocketServer.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServer</span> {</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">     <span class="keyword">try</span> {</span><br><span class="line">       <span class="comment">// 要接收的报文</span></span><br><span class="line">       <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">       <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line">       <span class="comment">// 创建socket并指定端口</span></span><br><span class="line">       <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8088</span>);</span><br><span class="line">       <span class="comment">// 接收socket客户端发送的数据。如果未收到会一致阻塞</span></span><br><span class="line">       socket.receive(packet);</span><br><span class="line">       <span class="type">String</span> <span class="variable">receiveMsg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(),<span class="number">0</span>,packet.getLength());</span><br><span class="line">       System.out.println(packet.getLength());</span><br><span class="line">       System.out.println(receiveMsg);</span><br><span class="line">       <span class="comment">// 关闭socket</span></span><br><span class="line">       socket.close();</span><br><span class="line">     } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">       <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     }</span><br><span class="line">   }</span><br><span class="line">}</span><br><span class="line">    运行时，先启动SocketServer，再启动SocketClient，会正常打印数据。在先启动SocketServer时，代码执行到socket.receive(packet)时会一致阻塞在这里，直到启动SocketClient后，SocketServer会继续执行，并将收到SocketClient的信息打印出来。如果是先启动SocketClient，会立即执行完毕，再执行SocketServer时，依旧会阻塞在receive方法处，直到下一次SocketClient的执行。</span><br></pre></td></tr></tbody></table></figure><p>原文链接：<a href="https://blog.csdn.net/u014209205/article/details/80461122">https://blog.csdn.net/u014209205/article/details/80461122</a></p><h3 id="JDBC编程"><a href="#JDBC编程" class="headerlink" title="JDBC编程"></a>JDBC编程</h3><h4 id="JDBC-编程步骤"><a href="#JDBC-编程步骤" class="headerlink" title="JDBC 编程步骤"></a>JDBC 编程步骤</h4><p>加载驱动程序：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(driverClass)</span><br><span class="line">//加载MySql驱动</span><br><span class="line">Class.forName("com.mysql.jdbc.Driver")</span><br><span class="line">//加载Oracle驱动</span><br><span class="line">Class.forName("oracle.jdbc.driver.OracleDriver")</span><br></pre></td></tr></tbody></table></figure><p>获得数据库连接：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/imooc", "root", "root");</span><br></pre></td></tr></tbody></table></figure><p>创建Statement\PreparedStatement对象：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn.createStatement();</span><br><span class="line">conn.prepareStatement(sql);</span><br></pre></td></tr></tbody></table></figure><h4 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DbUtil</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">"jdbc:mysql://localhost:3306/imooc"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">"liulx"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASSWORD</span> <span class="operator">=</span> <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">//1.加载驱动程序</span></span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        <span class="comment">//2. 获得数据库连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(URL, USER, PASSWORD);</span><br><span class="line">        <span class="comment">//3.操作数据库，实现增删改查</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">"SELECT user_name, age FROM imooc_goddess"</span>);</span><br><span class="line">        <span class="comment">//如果有数据，rs.next()返回true</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next()){</span><br><span class="line">            System.out.println(rs.getString(<span class="string">"user_name"</span>)+<span class="string">" 年龄："</span>+rs.getInt(<span class="string">"age"</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="PrepareStatement和Statement的区别"><a href="#PrepareStatement和Statement的区别" class="headerlink" title="PrepareStatement和Statement的区别"></a>PrepareStatement和Statement的区别</h4><p>PrepareStatement继承于Statement，包含execute()、 executeQuery() 和 executeUpdate()三种方法</p><p>1.PrepareStatement实例包含已经编译的SQL语句，会将SQL语句进行预编译，所以<strong>执行速度</strong><br><strong>比Statement高。</strong></p><p>prepareStatment事先对语句进行预处理，<strong>效率会高很多</strong>。Statment没有进行预处理，所以每次都要载入语句，所以效率比较低</p><p>2.PrepareStatement对象中的SQL语句可以包含一个或者多个参数，在SQL语句创建时<br>可以不指定参数，可以为参数位置保留一个？作为占位符，执行前通过适当的setInt()或者setString()方法来提供</p><p>3.用PrepareStatement<strong>可以防止sql注入</strong>，而Statement不行</p><p>所以我们尽量使用PrepareStatement。<br>————————————————<br>版权声明：本文为CSDN博主「dulalarepost」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/dulalarepost/article/details/100065799">https://blog.csdn.net/dulalarepost/article/details/100065799</a></p><h3 id="十四-正则表达式"><a href="#十四-正则表达式" class="headerlink" title="十四.正则表达式"></a>十四.正则表达式</h3><h4 id="含义："><a href="#含义：" class="headerlink" title="含义："></a>含义：</h4><p>正则表达式，又称正规表达式、常规表达式，使用字符串来描述、匹配一系列符合某个规则的字符串。</p><h4 id="正则表达式组成"><a href="#正则表达式组成" class="headerlink" title="正则表达式组成"></a>正则表达式组成</h4><h5 id="普通字符："><a href="#普通字符：" class="headerlink" title="普通字符："></a>普通字符：</h5><p>大小写字母、数字、标点符号及一些其他符号</p><h5 id="元字符："><a href="#元字符：" class="headerlink" title="元字符："></a>元字符：</h5><p>在正则表达式中具有特殊意义的专用字符</p><p>元字符<br>\：转义字符，!、\n等</p><p>^：匹配字符串开始的位置</p><p>例： ^a、^the、^#</p><p>$：匹配字符串结束的位置</p><p>例： word$</p><p>.：匹配除\n之外的任意的一个字符</p><p>例： go.d、g..d</p><p>*：匹配前面子表达式0次或者多次</p><p>例：goo*d、go.*d</p><p>[list]：匹配list列表中的一个字符</p><p>例： go[ola]d，[abc]、[a-z]、[a-z0-9]</p><p>[^list]：匹配任意不在list列表中的一个字符</p><p>例： <code>[^a-z]、[^0-9]、[^A-Z0-9]</code></p><p>{n,m}：匹配前面的子表达式n到m次，有{n}、{n,}、{n,m}三种格式</p><p>例：go{2}d、go{2,3}d、go{2,}d</p><h5 id="扩展元字符"><a href="#扩展元字符" class="headerlink" title="扩展元字符"></a>扩展元字符</h5><p>​       +：匹配前面子表达式1次以上</p><p>例： go+d，将匹配至少一个o</p><p>?：匹配前面子表达式0次或者1次</p><p>例： go?d，将匹配gd或god</p><p>()：将括号中的字符串作为一个整体</p><p>例：(xyz)+，将匹配 xyz 整体1次以上，如xyzxyz</p><p>|：以或的方式匹配字条串</p><p>例1： good|food，将匹配good或者food</p><p>例2： g(oo|la)d，将匹配good或者glad</p><p>使用grep匹配正则<br>       Grep 【选项】 查找条件 目标文件</p><p>-w:表示精确匹配</p><p>-E :开启扩展(Extend）的正则表达式</p><p>-c : 计算找到’搜寻字符串’的次数</p><p>-i :忽略大小写的不同，所以大小写视为相同</p><p>-o :只显示被模式匹配到的宁符串</p><p>-v:反向选择，亦即显示出没有’搜寻字符串′内容的那一行! (反向查找，输出与查找条件不相符的行)–color=auto : 可以将找到的关键词部分加上颜色的显示喔!</p><p>-n :顺便输出行号</p><p>​      </p><h4 id="基础正则表达式常见元字符"><a href="#基础正则表达式常见元字符" class="headerlink" title="基础正则表达式常见元字符"></a>基础正则表达式常见元字符</h4><p>:转义符，将特殊字符进行转义，忽略其特殊意义a.b匹配a.b，但不能匹配ajb，.被转义为特殊意义\\</p><p>^:匹配行首，^则是匹配字符串的开始^tux匹配以tux开头的行^^^^</p><p>$:匹配行尾，$则是匹配字符串的结尾tux$匹配以tux结尾的行<br>.:匹配除了换行符 \r\n之外的任意单个字符</p><p>[list]：匹配list列表中的一个字符</p><p>例： go[ola]d，[abc]、[a-z]、[a-z0-9]</p><p>[^list]：匹配任意不在list列表中的一个字符</p><p>例： <code>[^a-z]、[^0-9]、[^A-Z0-9]</code></p><p>{n,m}：匹配前面的子表达式n到m次，有{n}、{n,}、{n,m}三种格式</p><p>例：go{2}d、go{2,3}d、go{2,}d<br>原文链接：<a href="https://blog.csdn.net/a_b_e_l_/article/details/126239303">https://blog.csdn.net/a_b_e_l_/article/details/126239303</a></p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] agrs)</span> {</span><br><span class="line">   <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">"1234发覅肯定是粉底哦是覅偶矩3456dsfijkodsikloftejoif3456d'f'x'j'ko'p"</span>+</span><br><span class="line">         <span class="string">"萨蒂空腹喝阿斯偶阿三1234dfjidsfij吊死扶伤4567sdahjuadeisfrheufrhywufj5678"</span>;</span><br><span class="line">   <span class="comment">//目标：匹配所有四个数字</span></span><br><span class="line">   <span class="comment">//1.\\d表示一个任意的数字</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">regStr</span> <span class="operator">=</span> <span class="string">"\\d\\d\\d\\d"</span>;</span><br><span class="line">   <span class="comment">//创建模式对象（正则表达式对象）:</span></span><br><span class="line">   <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regStr);</span><br><span class="line">   <span class="comment">//创建匹配器:</span></span><br><span class="line">   <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line">   <span class="comment">//开始匹配</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * matcher.find() 完成的任务</span></span><br><span class="line"><span class="comment">    * 1.根据指定的规则，定位满足规则的字串</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">while</span>(matcher.find()){</span><br><span class="line">      System.out.println(<span class="string">"找到:"</span>+matcher.group(<span class="number">0</span>));</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="split用法"><a href="#split用法" class="headerlink" title="split用法"></a>split用法</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">splitDemo2</span><span class="params">()</span>{</span><br><span class="line">    String str= <span class="string">"a33b444c555d"</span>;</span><br><span class="line">    <span class="comment">//正则表达式中\d+表示一个或多个数字,java中\\表示一个普通\</span></span><br><span class="line">    <span class="comment">//String[] split = str.split(Pattern.compile("\\d+").toString());</span></span><br><span class="line">    <span class="comment">//两种写法都是一样的,下面写法简洁</span></span><br><span class="line">    String[] split = str.split(<span class="string">"\\d+"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; split.length; i++) {</span><br><span class="line">        System.out.println(split[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>————————————————<br>版权声明：本文为CSDN博主「一只光头猿」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_41740883/article/details/111696866">https://blog.csdn.net/qq_41740883/article/details/111696866</a></p><h3 id="十七-类和变量"><a href="#十七-类和变量" class="headerlink" title="十七.类和变量"></a>十七.类和变量</h3><h4 id="一、类："><a href="#一、类：" class="headerlink" title="一、类："></a>一、类：</h4><p>类似于一个模板，它描述一类事物的行为和状态。比如：人、动物。</p><p>class关键字用来定义类，多个字母组成的话注意驼峰表示，首字母大写。</p><h4 id="二、对象："><a href="#二、对象：" class="headerlink" title="二、对象："></a>二、对象：</h4><p>类的一个具体实例，有属性和行为。比如：一条狗是一个对象。它的属性有颜色，名字，品种等。它的行为有吃饭，叫，摇尾巴。</p><h4 id="三、变量："><a href="#三、变量：" class="headerlink" title="三、变量："></a>三、变量：</h4><p>分为：成员变量、静态变量、局部变量等</p><p>成员变量：定义在类中，方法体之外。非static变量。</p><p>静态变量：也叫<strong>类变量</strong>，也是定义在类中，方法体之外，但是必须声明为Static类型。</p><p>局部变量：定位在方法体，语句块或构造方法中的变量。名字首字母小写，多个字母驼峰形式。</p><h4 id="四、常量"><a href="#四、常量" class="headerlink" title="四、常量"></a>四、常量</h4><p>final关键字用于定义常量，通常都是全部大写。</p><h4 id="五、方法"><a href="#五、方法" class="headerlink" title="五、方法"></a>五、方法</h4><p>方法定义：修饰符+返回类型+方法名+参数+方法体</p><p>当方法不需要返回值的时候，方法的类型必须是void</p><h4 id="六、构造方法"><a href="#六、构造方法" class="headerlink" title="六、构造方法"></a>六、构造方法</h4><p>每个类都有构造方法，如果没有显示的定义构造方法，Java编译器将会为该类提供一个默认的构造方法。</p><p>构造方法的名称必须与类名相同，一个类可以有多个构造方法。不能被static修饰。</p><p>目的是为了创建对象</p><h4 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h4><p><img src="https://img-blog.csdnimg.cn/20210702211139141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FuZ2Jvb20=,size_16,color_FFFFFF,t_70" alt="img">·</p><p>————————————————<br>版权声明：本文为CSDN博主「angboom」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/angboom/article/details/118423158">https://blog.csdn.net/angboom/article/details/118423158</a></p><h4 id="八、补充"><a href="#八、补充" class="headerlink" title="八、补充"></a>八、补充</h4><p><strong>类方法就是static修饰的静态方法</strong>。(主函数main就是类方法)<br>当方法是静态方式时,是不能用this来调用本类的方法的(this是指当前对象，类方法中还不存在对象的说法)。静态方法是跟着类走的，所以this表示的当前对象不确定，不能用this调用。直接调用即可<br>this指当前对象只能在实例方法和构造函数中调用。</p><p>在类方法中调用本类的类方法可直接调用。<br>实例方法也叫做对象方法。<br><strong>类方法是属于整个类的，</strong><br><strong>而实例方法是属于类的某个对象的。</strong><br>由于类方法是属于整个类的，并不属于类的哪个对象，所以类方法的方法体中不能有与类的对象有关的内容。即类方法体有如下限制：</p><p><strong>(1) 类方法中不能引用对象变量；</strong><br><strong>(2) 类方法中不能调用类的对象方法；</strong><br><strong>(3) 在类方法中不能使用super、this关键字。</strong><br><strong>(4)类方法不能被覆盖</strong>。</p><p>如果违反这些限制，就会导致程序编译错误。<br>与类方法相比，对象方法几乎没有什么限制：</p><p><strong>(1) 对象方法中可以引用对象变量，也可以引用类变量；</strong><br><strong>(2) 对象方法中可以调用类方法；</strong><br><strong>(3) 对象方法中可以使用super、this关键字。</strong></p><p>static块、方法中不可出现this、super关键字。<br>类方法中可以调用其他类的类方法。<br>在类方法里，创建一个对象，通过对象调用方法。相当于间接调用</p><p>同类中this可以表示隐匿参数类型（比如，在构造器中进行实例域初始化时，如this.data = data;），也可以调用构造器（比如在方法中调用本类的构造器）。其实际就是当前类的类换一个马甲，不至于引发混乱。<br>比如Sting类， 构造器public string（）；实际上也可理解为pulic (String) String();或者public this String();。<br>————————————————<br>版权声明：本文为CSDN博主「喽耶」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_45122172/article/details/120691651">https://blog.csdn.net/weixin_45122172/article/details/120691651</a></p><p>在Java中，没有类就不能做任何事情；但是需要注意的是，虽然Java是一门完全面向对象的编程语言，但不代表Java中所有的类都是面向对象，比如说Math类，只需要调用该类的方法去实现某个特定的功能即可，而无需了解具体的实现过程，这也是类的封装所在。</p><p>在工程中，我们大多数的类还是面向对象的，包括JDK中的，也包括第三方的，当然也包括我们<a href="https://www.yht7.com/news/2243">自定义的类</a>,要使用这些类，那么我们就需要通过这个类来构建一个对象，然后对对象应用方法，在Java中，使用构造器来构建对象，构造器是一个特殊的方法，用来构造并初始化一个对象,构造器的名字必须与类名相同，比如Date类吧，那么Date的构造器就叫做Date,构建一个Date时，加上new关键字即可，像这样：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></tbody></table></figure><p>还可以将构建出来的对象放在一个变量中，以便可以多次使用，那么这个变量就是<strong>对象变量</strong>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></tbody></table></figure><ul><li>date就是一个对象变量；</li></ul><h4 id="九、对象和对象变量之间的区别："><a href="#九、对象和对象变量之间的区别：" class="headerlink" title="九、对象和对象变量之间的区别："></a>九、对象和对象变量之间的区别：</h4><p>更好的说明这两者之间的区别，还是通过一个例子来看：</p><p>如下：定义一个对象变量deadLine：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date deadLine ;  <span class="comment">// 此时deadLine没有引用任何对象</span></span><br></pre></td></tr></tbody></table></figure><ul><li>这样deadLine就可以引用一个Date类型的对象，但是一定要区分，deadLine并不是一个对象，而是一个对象变量，此时deadLine并没有引用任何Date对象，因此也不能调用任何Date类的方法，否则报错空指针；</li><li>此时有两种方法对deadLine进行初始化：</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 让deadLine引用一个新创建的Date对象</span></span><br><span class="line">deadLine = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">// 2. 让deadLine指向一个已经存在的对象变量，比如之前的date对象变量</span></span><br><span class="line">deadLine = date;</span><br></pre></td></tr></tbody></table></figure><p>一定需要注意的就是，一个对象变量没有实际包含一个对象，而仅仅是引用了一个对象。</p><p>在Java中，任何对象变量的值都是对存储在另一个地方的一个对象的引用，new操作符的返回值就是一个对象，其实对象变量是存储在栈内存中，而对象的引用存储在堆内存中；如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></tbody></table></figure><p><img src="https://www.yht7.com/upload/image/20191110/6bc7850e0538500977b9ea150d70f556293.jpg" alt="对象和对象变量"></p><p>这句话包含了两个部分，表达式new Date() 构建了一个Date类型的对象，并把它的值赋于对象变量date，对象变量date中存储了这个对象的引用。</p><p>同样，我们将date这个对象变量设置为null，表示这个对象变量不引用任何对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date = <span class="literal">null</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>另外需要注意的是，Java中局部变量不会自动的初始化，必须通过new或者显式的置为null进行初始化。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
