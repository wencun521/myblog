<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>进程 · 温存的小窝</title><meta name="description" content="概念提出进程是60年代初首先由麻省理工学院的MULTICS系统和IBM公司的CTSS/360系统引入的。 [2] 
进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理"><meta name="og:description" content="概念提出进程是60年代初首先由麻省理工学院的MULTICS系统和IBM公司的CTSS/360系统引入的。 [2] 
进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理"><meta name="twitter:site" content="温存的小窝"><meta name="twitter:title" content="进程"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 5.4.2">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div class="container" id="stage"><div class="row"><div class="col-sm-3 col-xs-12 side-container invisible" id="side-bar"><div class="vertical-text site-title"><h3 class="site-title-small" tabindex="-1"><a class="a-title" href="/">Typography</a></h3><h1 class="site-title-large" tabindex="-1"><a class="a-title" href="/">活版印字</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div class="site-title-links" id="site-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/tags">Tags</a></li><li><a href="/about/index.html">about</a></li><li><a href="/categories/index.html">分类</a></li><li><a href="/contact/index.html">contact</a></li><li><a href="/tags/index.html">标签</a></li><li><a href="/friends/index.html">friends</a></li><li><a href="/mapDepot/index.html">mapDepot</a></li><li><a href="/link/index.html">友情链接</a></li><li class="soc"><a href="https://wencun.love/atom.xml" target="_blank" rel="noopener noreferrer" aria-label="RSS"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2023&nbsp;<a target="_blank" href="https://wencun.love" rel="noopener noreferrer">温存</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div class="col-sm-9 col-xs-12 main-container invisible" id="main-container"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>进程</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2023-04-02</span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a class="a-tag" href="/tags/操作系统/" title="操作系统">操作系统</a><span>&nbsp;</span></span></p><p class="post-abstract"><h2 id="概念提出"><a href="#概念提出" class="headerlink" title="概念提出"></a>概念提出</h2><p>进程是60年代初首先由<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5%E5%AD%A6%E9%99%A2?fromModule=lemma_inlink">麻省理工学院</a>的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/MULTICS%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">MULTICS系统</a>和IBM公司的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/CTSS?fromModule=lemma_inlink">CTSS</a>/360系统引入的。 [2] </p>
<p>进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81?fromModule=lemma_inlink">代码</a>，还包括当前的活动，通过<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8?fromModule=lemma_inlink">程序计数器</a>的值和处理<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8?fromModule=lemma_inlink">寄存器</a>的内容来表示。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>狭义定义：进程是正在运行的程序的实例（an instance of a computer program that is being executed）。</p>
<p>广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192?fromModule=lemma_inlink">操作系统</a>动态执行的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83?fromModule=lemma_inlink">基本单元</a>，在传统的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">操作系统</a>中，进程既是基本的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%88%86%E9%85%8D%E5%8D%95%E5%85%83?fromModule=lemma_inlink">分配单元</a>，也是基本的执行单元。</p>
<p>进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%96%87%E6%9C%AC?fromModule=lemma_inlink">文本</a>区域（text region）、数据区域（data region）和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88?fromModule=lemma_inlink">堆栈</a>（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86?fromModule=lemma_inlink">处理</a>器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B?fromModule=lemma_inlink">进程</a>。 [3] </p>
<p>进程是操作系统中最基本、重要的概念。是多道程序系统出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律引进的一个概念,所有多道程序设计操作系统都建立在进程的基础上。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>操作系统引入进程的概念的原因:</p>
<p>从理论角度看，是对正在运行的程序过程的抽象；</p>
<p>从实现角度看，是一种<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84?fromModule=lemma_inlink">数据结构</a>，目的在于清晰地刻画<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">动态系统</a>的内在规律，有效管理和调度进入<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">计算机系统</a><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8?fromModule=lemma_inlink">主存储器</a>运行的程序。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>动态性：进程的实质是程序在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">多道程序系统</a>中的一次执行过程，进程是动态产生，动态消亡的。</p>
<p>并发性：任何进程都可以同其他进程一起并发执行</p>
<p>独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位；</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BC%82%E6%AD%A5%E6%80%A7?fromModule=lemma_inlink">异步性</a>：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进</p>
<p>结构特征：进程由程序、数据和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97?fromModule=lemma_inlink">进程控制块</a>三部分组成。</p>
<p>多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果；但是执行过程中，程序不能发生改变。</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>一个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">计算机系统</a>进程包括（或者说“拥有”）下列数据：</p>
<p>那个程序的可运行<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E7%A0%81?fromModule=lemma_inlink">机器码</a>的一个在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8?fromModule=lemma_inlink">存储器</a>的映像。 分配到的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8?fromModule=lemma_inlink">存储器</a>（通常包括<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98?fromModule=lemma_inlink">虚拟内存</a>的一个区域）。<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8?fromModule=lemma_inlink">存储器</a>的内容包括可运行<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81?fromModule=lemma_inlink">代码</a>、特定于进程的数据（输入、输出）、调用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88?fromModule=lemma_inlink">堆栈</a>、堆栈（用于保存运行时运数中途产生的数据）。 分配给该进程的资源的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">操作系统</a>描述符，诸如文件描述符（<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Unix?fromModule=lemma_inlink">Unix</a>术语）或<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84?fromModule=lemma_inlink">文件句柄</a>（Windows）、数据源和数据终端。 安全特性，诸如进程拥有者和进程的权限集（可以容许的操作）。 处理器状态（内文），诸如<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8?fromModule=lemma_inlink">寄存器</a>内容、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8%E5%99%A8?fromModule=lemma_inlink">物理存储器</a>寻址等。当进程正在运行时，状态通常储存在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8?fromModule=lemma_inlink">寄存器</a>，其他<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%83%85%E5%86%B5?fromModule=lemma_inlink">情况</a>在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8?fromModule=lemma_inlink">存储器</a>。</p>
<h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/pic/%E8%BF%9B%E7%A8%8B/382503/0/ac2fc3c459bc3aae38db4968?fr=lemma&amp;fromModule=lemma_content-image&amp;ct=single"><img src="https://s2.loli.net/2023/04/05/zMK1tTeCPG3BsiI.jpg" alt="Windows 和Windows Vista 体系结构"></a>Windows 和Windows Vista 体系结构</p>
<p>进行<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2?fromModule=lemma_inlink">进程切换</a>就是从正在运行的进程中收回<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E5%99%A8?fromModule=lemma_inlink">处理器</a>，然后再使待运行进程来占用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E5%99%A8?fromModule=lemma_inlink">处理器</a>。</p>
<p>这里所说的从某个进程收回<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E5%99%A8?fromModule=lemma_inlink">处理器</a>，实质上就是把进程存放在处理器的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8?fromModule=lemma_inlink">寄存器</a>中的中间数据找个地方存起来，从而把处理器的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8?fromModule=lemma_inlink">寄存器</a>腾出来让其他进程使用。那么被中止运行进程的中间数据存在何处好呢？当然这个地方应该是进程的私有<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88?fromModule=lemma_inlink">堆栈</a>。</p>
<p>让进程来占用处理器，实质上是把某个进程存放在私有<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88?fromModule=lemma_inlink">堆栈</a>中<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8?fromModule=lemma_inlink">寄存器</a>的数据（前一次本进程被中止时的中间数据）再恢复到处理器的寄存器中去，并把待运行进程的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%96%AD%E7%82%B9?fromModule=lemma_inlink">断点</a>送入处理器的程序<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88?fromModule=lemma_inlink">指针</a>PC，于是待运行进程就开始被处理器运行了，也就是这个进程已经占有处理器的使用权了。</p>
<p>这就像多个同学要分时使用同一张课桌一样，所谓要收回正在使用课桌同学的课桌使用权，实质上就是让他把属于他的东西拿走；而赋予某个同学课桌使用权，只不过就是让他把他的东西放到课桌上罢了。</p>
<p>在切换时，一个进程存储在处理器各<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8?fromModule=lemma_inlink">寄存器</a>中的中间数据叫做进程的上下文，所以进程的 切换实质上就是被中止运行进程与待运行<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87?fromModule=lemma_inlink">进程上下文</a>的切换。在进程未占用处理器时，进程 的上下文是存储在进程的私有<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88?fromModule=lemma_inlink">堆栈</a>中的。</p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/pic/%E8%BF%9B%E7%A8%8B/382503/0/d089b986cb94db6866096e7e?fr=lemma&amp;fromModule=lemma_content-image&amp;ct=single"><img src="https://s2.loli.net/2023/04/05/hf3yH41GNLxpcd5.jpg" alt="进程的三个基本状态"></a>进程的三个基本状态</p>
<p>进程执行时的间断性，决定了进程可能具有多种状态。事实上，运行中的进程可能具有以下三种基本状态。</p>
<p><strong>1）</strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81?fromModule=lemma_inlink">就绪状态</a><strong>（Ready）：</strong></p>
<p>进程已获得除处理器外的所需<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%B5%84%E6%BA%90?fromModule=lemma_inlink">资源</a>，等待分配处理器资源；只要分配了处理器进程就可执行。就绪进程可以按多个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BC%98%E5%85%88%E7%BA%A7?fromModule=lemma_inlink">优先级</a>来划分<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97?fromModule=lemma_inlink">队列</a>。例如，当一个进程由于时间片用完而进入<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81?fromModule=lemma_inlink">就绪状态</a>时，排入低<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97?fromModule=lemma_inlink">优先级队列</a>；当进程由<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/I%2FO%E6%93%8D%E4%BD%9C?fromModule=lemma_inlink">I/O操作</a>完成而进入<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81?fromModule=lemma_inlink">就绪状态</a>时，排入高优先级队列。</p>
<p><strong>2）运行状态(Running)：</strong></p>
<p>进程占用处理器资源；处于此状态的进程的数目小于等于处理器的数目。在没有其他进程可以执行时(如所有进程都在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81?fromModule=lemma_inlink">阻塞状态</a>)，通常会自动执行系统的空闲进程。</p>
<p><strong>3）</strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81?fromModule=lemma_inlink">阻塞状态</a>(<strong>Blocked</strong>)：</p>
<p>由于进程等待某种条件（如I/O操作或<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5?fromModule=lemma_inlink">进程同步</a>），在条件满足之前无法继续执行。该事件发生前即使把处理器资源分配给该进程，也无法运行。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><strong>程序</strong></p>
<p>程序是指令和数据的有序<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9B%86%E5%90%88?fromModule=lemma_inlink">集合</a>，其本身没有任何运行的含义，是一个静态的概念。而进程是程序在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA?fromModule=lemma_inlink">处理机</a>上的一次执行过程，它是一个动态的概念。</p>
<p>程序可以作为一种<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6?fromModule=lemma_inlink">软件</a>资料长期存在，而进程是有一定生命期的。程序是永久的，进程是暂时的。</p>
<p>进程更能真实地描述并发，而程序不能；</p>
<p>进程是由<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97?fromModule=lemma_inlink">进程控制块</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E6%AE%B5?fromModule=lemma_inlink">程序段</a>、数据段三部分组成;</p>
<p>进程具有创建其他进程的功能，而程序没有。</p>
<p>同一程序同时运行于若干个数据集合上，它将属于若干个不同的进程，也就是说同一程序可以对应多个进程。</p>
<p>在传统的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">操作系统</a>中，程序并不能独立运行，作为资源分配和独立运行的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83?fromModule=lemma_inlink">基本单元</a>都是进程。</p>
<p><strong>线程</strong></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/pic/%E8%BF%9B%E7%A8%8B/382503/0/f95898180b7961d14aedbcce?fr=lemma&amp;fromModule=lemma_content-image&amp;ct=single"><img src="https://s2.loli.net/2023/04/05/D6uN4rECdHTkFJp.jpg" alt="进程和线程关系"></a>进程和线程关系</p>
<p>通常在一个进程中可以包含若干个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B?fromModule=lemma_inlink">线程</a>，它们可以利用进程所拥有的资源，在引入<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B?fromModule=lemma_inlink">线程</a>的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">操作系统</a>中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B?fromModule=lemma_inlink">线程</a>比进程更小，基本上不拥有<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90?fromModule=lemma_inlink">系统资源</a>，故对它的调度所付出的开销就会小得多，能更高效的提高系统内多个程序间并发执行的程度。</p>
<p><strong>管程</strong></p>
<p>系统中的各种硬件资源和软件资源,均可用数据结构抽象地描述其资源特性,即用少量信息和对资源所执行的操作来表征该资源,而忽略了它们的内部结构和实现细节。</p>
<p>利用共享数据结构抽象地表示系统中的共享资源,而把对该共享数据结构实施的操作定义为一组过程。</p>
<p>代表共享资源的数据结构,以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序,共同构成了一个操作系统的资源管理模块,我们称之为管程。</p>
<p>一个管程定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作,这组操作能同步进程和改变管程中的数据局部于管程的数据结构,只能被局部于管程的过程所访问,任何管程之外的过程都不能访问它;反之,局部于管程的过程也只能访问管程内的数据结构。由此可见,管程相当于围墙,它把共享变量和对它进行操作的若干个过程围了起来,所有进程要访问临界资源时,都必须经过管程才能进入,而管程每次只允许一个进程进入管程,从而实现了进程的互斥。 [5] </p>
<p>当下推出的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%80%9A%E7%94%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">通用操作系统</a>都引入了<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B?fromModule=lemma_inlink">线程</a>，以便进一步提高系统的并发性，并把它视为<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">现代操作系统</a>的一个重要指标。</p>
<h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p>进程控制是进程管理中最基本的功能。它用于创建一个新进程，终止一个已完成的进程，或者去终止一个因出现某事件而使其无法运行下去的进程，还可负责进程运行中的状态转换。</p>
<p><strong>创建进程</strong></p>
<p><strong>1.引起创建进程的事件</strong></p>
<p>在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F?fromModule=lemma_inlink">多道程序</a>环境中，只有（作为）进程（时）才能在系统中运行。因此，为使程序能运行，就必须为它创建进程。导致一个进程去创建另一个进程的典型事件，可以有以下四类：</p>
<p>1） 用户登录</p>
<p>在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">分时系统</a>中，用户在终端键入登录命令后，如果是合法用户，系统将为该终端建立一个进程，并把它插入到就绪<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97?fromModule=lemma_inlink">队列</a>中。</p>
<p>2）<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6?fromModule=lemma_inlink">作业调度</a></p>
<p>在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">批处理系统</a>中，当作业调度程序按照一定的算法调度到某作业时，便将该作业装入到<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98?fromModule=lemma_inlink">内存</a>，为它分配必要的资源，并立即为它创建进程，再插入到就绪<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97?fromModule=lemma_inlink">队列</a>中。</p>
<p>3） 提供服务</p>
<p>当运行中的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F?fromModule=lemma_inlink">用户程序</a>提出某种请求后，系统将专门创建一个进程来提供用户所需要的服务，例如，用户程序要求进行文件打印，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">操作系统</a>将为它创建一个打印进程，这样，不仅可以使打印进程与该用户进程并发执行，而且还便于计算出为完成打印任务所花费的时间。</p>
<p>4） 应用请求</p>
<p>在上述三种<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%83%85%E5%86%B5?fromModule=lemma_inlink">情况</a>中，都是由系统<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8?fromModule=lemma_inlink">内核</a>为它创建一个新进程，而这一类事件则是基于应用进程的需求，由它创建一个新的进程，以便使新进程以并发的运行方式完成特定任务。</p>
<p><strong>2.进程的创建过程</strong></p>
<p>一旦<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">操作系统</a>发现了要求创建新进程的事件后，便调用进程创建<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E8%AF%AD?fromModule=lemma_inlink">原语</a>create()按下述步骤创建一个新进程。</p>
<p>1） 申请空白PCB。为新进程申请获得唯一的数字<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A0%87%E8%AF%86%E7%AC%A6?fromModule=lemma_inlink">标识符</a>，并从PCB集合中索取一个空白PCB。</p>
<p>2） 为新进程分配资源。为新进程的程序和数据以及<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%94%A8%E6%88%B7%E6%A0%88?fromModule=lemma_inlink">用户栈</a>分配必要的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98?fromModule=lemma_inlink">内存</a>空间。显然，此时<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">操作系统</a>必须知道新进程所需要的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98?fromModule=lemma_inlink">内存</a>大小。</p>
<p>3） 初始化<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97?fromModule=lemma_inlink">进程控制块</a>。PCB的初始化包括：</p>
<p>①初始化标识信息，将系统分配的标识符和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%88%B6%E8%BF%9B%E7%A8%8B?fromModule=lemma_inlink">父进程</a>标识符，填入新的PCB中。</p>
<p>②初始化<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA?fromModule=lemma_inlink">处理机</a>状态信息，使<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8?fromModule=lemma_inlink">程序计数器</a>指向程序的入口地址，使栈<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88?fromModule=lemma_inlink">指针</a>指向栈顶。</p>
<p>③初始化<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA?fromModule=lemma_inlink">处理机</a>控制信息，将进程的状态设置为<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81?fromModule=lemma_inlink">就绪状态</a>或静止就绪状态，对于优先级，通常是将它设置为最低优先级，除非用户以显式的方式提出高优先级要求。</p>
<p>4） 将新进程插入就绪队列，如果进程就绪<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97?fromModule=lemma_inlink">队列</a>能够接纳新进程，便将新进程插入到就绪队列中。</p>
<p><strong>进程终止</strong></p>
<p><strong>1.引起进程终止的事件</strong></p>
<p>1）正常结束</p>
<p>在任何<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">计算机系统</a>中，都应该有一个表示进程已经运行完成的指示。例如，在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">批处理系统</a>中，通常在程序的最后安排一条Hold指令或终止的系统调用。当程序运行到Hold指令时，将产生一个中断，去通知OS本进程已经完成。</p>
<p>2）异常结束</p>
<p>在进程运行期间，由于出现某些错误和故障而迫使进程终止。这类异常事件很多，常见的有：越界错误，保护错，非法指令，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4?fromModule=lemma_inlink">特权指令</a>错，运行超时，等待超时，算术运算错，I/O故障。</p>
<p>3）外界干预</p>
<p>外界干预并非指在本进程运行中出现了异常事件，而是指进程应外界的请求而终止运行。这些干预有：操作员或<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">操作系统</a>干预，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%88%B6%E8%BF%9B%E7%A8%8B?fromModule=lemma_inlink">父进程</a>请求，父进程终止。</p>
<p><strong>2. 进程的终止过程</strong></p>
<p>如果系统发生了上述要求终止进程的某事件后，OS便调用进程终止<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E8%AF%AD?fromModule=lemma_inlink">原语</a>，按下述过程去终止指定的进程。</p>
<p>1）根据被终止进程的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A0%87%E8%AF%86%E7%AC%A6?fromModule=lemma_inlink">标识符</a>，从PCB集合中检索出该进程的PCB，从中读出该进程状态。</p>
<p>2）若被终止进程正处于<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%89%A7%E8%A1%8C%E7%8A%B6%E6%80%81?fromModule=lemma_inlink">执行状态</a>，应立即终止该进程的执行，并置调度标志为真。用于指示该进程被终止后应重新进行调度。</p>
<p>3）若该进程还有子孙进程，还应将其所有子孙进程予以终止，以防他们成为不可控的进程。</p>
<p>4）将被终止的进程所拥有的全部资源，或者归还给其父进程，或者归还给系统。</p>
<p>5）将被终止进程（它的PCB）从所在队列（或链表）中移出，等待其它程序来搜集信息。</p>
<p><strong>阻塞唤醒</strong></p>
<p><strong>1.引起进程阻塞和唤醒的事件</strong></p>
<p>1）请求<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1?fromModule=lemma_inlink">系统服务</a></p>
<p>当正在执行的进程请求<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">操作系统</a>提供服务时，由于某种原因，操作系统并不立即满足该进程的要求时，该进程只能转变为<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81?fromModule=lemma_inlink">阻塞状态</a>来等待，一旦要求得到满足后，进程被唤醒。</p>
<p>2）启动某种操作</p>
<p>当进程启动某种操作后，如果该进程必须在该操作完成之后才能继续执行，则必须先使该进程阻塞，以等待该操作完成，该操作完成后，将该进程唤醒。</p>
<p>3）新数据尚未到达</p>
<p>对于相互合作的进程，如果其中一个进程需要先获得另一（合作）进程提供的数据才能运行以对数据进行处理，则是要其所需数据尚未到达，该进程只有（等待）阻塞，等到数据到达后，该进程被唤醒。</p>
<p>4）无新工作可做</p>
<p>系统往往设置一些具有某特定功能的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B?fromModule=lemma_inlink">系统进程</a>，每当这种进程完成任务后，便把自己阻塞起来以等待新任务到来，新任务到达后，该进程被唤醒。</p>
<p><strong>2.进程阻塞过程</strong></p>
<p>正在执行的进程，当发现上述某事件后，由于无法继续执行，于是进程便通过调用阻塞<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E8%AF%AD?fromModule=lemma_inlink">原语</a>block()把自己阻塞。可见，进程的阻塞是进程自身的一种主动行为。进入block过程后，由于此时该进程还处于<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%89%A7%E8%A1%8C%E7%8A%B6%E6%80%81?fromModule=lemma_inlink">执行状态</a>，所以应先立即停止执行，把<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97?fromModule=lemma_inlink">进程控制块</a>中的现行状态由执行改为阻塞，并将PCB插入阻塞<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97?fromModule=lemma_inlink">队列</a>。如果系统中设置了因不同事件而阻塞的多个阻塞<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97?fromModule=lemma_inlink">队列</a>，则应将本进程插入到具有相同事件的阻塞（等待）队列。最后，转调度程序进行重新调度，将<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA?fromModule=lemma_inlink">处理机</a>分配给另一就绪进程，并进行切换，亦即，保留被阻塞进程的处理机状态（在PCB中），再按新进程的PCB中的处理机状态设置CPU环境。</p>
<p><strong>3. 进程唤醒过程</strong></p>
<p>当被阻塞的进程所期待的事件出现时，如I/O完成或者其所期待的数据已经到达，则由有关进程（比如，用完并释放了该I/O设备的进程）调用唤醒原语wakeup()，将等待该事件的进程唤醒。唤醒原语执行的过程是：首先把被阻塞的进程从等待该事件的阻塞<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97?fromModule=lemma_inlink">队列</a>中移出，将其PCB中的现行状态由阻塞改为就绪，然后再将该PCB插入到就绪队列中。</p>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>进程的调度算法包括：</p>
<p>实时系统中：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/FIFO/64838?fromModule=lemma_inlink">FIFO</a>(First Input First Output，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA?fromModule=lemma_inlink">先进先出</a>算法)，SJF(Shortest Job First，最短作业优先算法)，SRTF(Shortest Remaining Time First，最短剩余时间优先算法）。</p>
<p>交互式系统中：RR(Round Robin，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC?fromModule=lemma_inlink">时间片轮转</a>算法)，HPF(Highest Priority First，最高优先级算法)，多级队列，最短进程优先，保证调度，彩票调度，公平分享调度。</p>
<h3 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h3><p>进程是由<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97?fromModule=lemma_inlink">进程控制块</a>、程序段、数据段三部分组成。一个进程可以包含若干<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B?fromModule=lemma_inlink">线程</a>(Thread)，线程可以帮助应用程序同时做几件事(比如一个线程向<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%A3%81%E7%9B%98?fromModule=lemma_inlink">磁盘</a>写入文件，另一个则接收用户的按键操作并及时做出反应，互相不干扰)，在程序被运行后，系统首先要做的就是为该程序进程建立一个默认线程，然后程序可以根据需要自行添加或删除相关的线程。是可并发执行的程序。在一个数据集合上的运行过程，是系统进行资源分配和调度的一个独立单位，也是称活动、路径或任务，它有两方面性质：活动性、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91%E6%80%A7?fromModule=lemma_inlink">并发性</a>。进程可以划分为运行、阻塞、就绪三种状态，并随一定条件而相互转化：就绪–运行，运行–阻塞，阻塞–就绪。</p>
<p>进程为应用程序的运行实例，是应用程序的一次动态执行。看似高深，我们可以简单地理解为：它是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">操作系统</a>当前运行的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F?fromModule=lemma_inlink">执行程序</a>。在系统当前运行的执行程序里包括：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E8%AE%A1%E7%AE%97%E6%9C%BA?fromModule=lemma_inlink">系统管理计算机</a>个体和完成各种操作所必需的程序；用户开启、执行的额外程序，当然也包括用户不知道，而自动运行的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E7%A8%8B%E5%BA%8F?fromModule=lemma_inlink">非法程序</a>（它们就有可能是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%97%85%E6%AF%92?fromModule=lemma_inlink">病毒</a>程序）。  </p>
<blockquote>
<p>来自百度百科</p>
</blockquote>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></span><span class="soc"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></span><span class="soc"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=https://wencun.love/2023/04/02/进程/%20温存的小窝%20进程"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2023/04/02/%E4%B8%B4%E7%95%8C%E5%8C%BA%E5%92%8C%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90/" title="临界区与临界资源"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: 临界区与临界资源</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2022/11/07/JAVA%E5%A4%8D%E4%B9%A0/" title="java复习">Next post: java复习&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2023&nbsp;<a target="_blank" href="https://wencun.love" rel="noopener noreferrer">温存</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>